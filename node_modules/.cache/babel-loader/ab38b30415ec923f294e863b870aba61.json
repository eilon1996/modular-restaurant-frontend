{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/eilon/programing/full-stack/React/confusion/confusion-new/confusion/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/home/eilon/programing/full-stack/React/confusion/confusion-new/confusion/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/eilon/programing/full-stack/React/confusion/confusion-new/confusion/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"/home/eilon/programing/full-stack/React/confusion/confusion-new/confusion/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"/home/eilon/programing/full-stack/React/confusion/confusion-new/confusion/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/home/eilon/programing/full-stack/React/confusion/confusion-new/confusion/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = function isHTMLElement(value) {\n  return value instanceof HTMLElement;\n};\n\nvar EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nvar VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all'\n};\nvar VALUE = 'value';\nvar SELECT = 'select';\nvar UNDEFINED = 'undefined';\nvar INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nfunction attachEventListeners(_ref, shouldAttachChangeEvent, handleChange) {\n  var ref = _ref.ref;\n\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isNullOrUndefined = function isNullOrUndefined(value) {\n  return value == null;\n};\n\nvar isArray = function isArray(value) {\n  return Array.isArray(value);\n};\n\nvar isObjectType = function isObjectType(value) {\n  return typeof value === 'object';\n};\n\nvar isObject = function isObject(value) {\n  return !isNullOrUndefined(value) && !isArray(value) && isObjectType(value) && !(value instanceof Date);\n};\n\nvar isKey = function isKey(value) {\n  return !isArray(value) && (/^\\w*$/.test(value) || !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n};\n\nvar stringToPath = function stringToPath(input) {\n  var result = [];\n  input.replace(/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, function (match, mathNumber, mathQuote, originalString) {\n    result.push(mathQuote ? originalString.replace(/\\\\(\\\\)?/g, '$1') : mathNumber || match);\n  });\n  return result;\n};\n\nfunction set(object, path, value) {\n  var index = -1;\n  var tempPath = isKey(path) ? [path] : stringToPath(path);\n  var length = tempPath.length;\n  var lastIndex = length - 1;\n\n  while (++index < length) {\n    var key = tempPath[index];\n    var newValue = value;\n\n    if (index !== lastIndex) {\n      var objValue = object[key];\n      newValue = isObject(objValue) || isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = function transformToNestObject(data) {\n  return Object.entries(data).reduce(function (previous, _ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        key = _ref3[0],\n        value = _ref3[1];\n\n    if (!isKey(key)) {\n      set(previous, key, value);\n      return previous;\n    }\n\n    return Object.assign(Object.assign({}, previous), _defineProperty({}, key, value));\n  }, {});\n};\n\nvar isUndefined = function isUndefined(val) {\n  return val === undefined;\n};\n\nvar filterOutFalsy = function filterOutFalsy(value) {\n  return value.filter(Boolean);\n};\n\nvar get = function get(obj, path, defaultValue) {\n  var result = filterOutFalsy(path.split(/[,[\\].]+?/)).reduce(function (result, key) {\n    return isNullOrUndefined(result) ? result : result[key];\n  }, obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nvar focusOnErrorField = function focusOnErrorField(fields, fieldErrors) {\n  for (var key in fields) {\n    if (get(fieldErrors, key)) {\n      var field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          field.ref.focus();\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\n\nvar removeAllEventListeners = function removeAllEventListeners(ref, validateWithStateUpdate) {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nvar defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nvar getRadioValue = function getRadioValue(options) {\n  return isArray(options) ? options.reduce(function (previous, option) {\n    return option && option.ref.checked ? {\n      isValid: true,\n      value: option.ref.value\n    } : previous;\n  }, defaultReturn) : defaultReturn;\n};\n\nvar getMultipleSelectValue = function getMultipleSelectValue(options) {\n  return _toConsumableArray(options).filter(function (_ref4) {\n    var selected = _ref4.selected;\n    return selected;\n  }).map(function (_ref5) {\n    var value = _ref5.value;\n    return value;\n  });\n};\n\nvar isRadioInput = function isRadioInput(element) {\n  return element.type === 'radio';\n};\n\nvar isFileInput = function isFileInput(element) {\n  return element.type === 'file';\n};\n\nvar isCheckBoxInput = function isCheckBoxInput(element) {\n  return element.type === 'checkbox';\n};\n\nvar isMultipleSelect = function isMultipleSelect(element) {\n  return element.type === \"\".concat(SELECT, \"-multiple\");\n};\n\nvar defaultResult = {\n  value: false,\n  isValid: false\n};\nvar validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = function getCheckboxValue(options) {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      var values = options.filter(function (option) {\n        return option && option.ref.checked;\n      }).map(function (_ref6) {\n        var value = _ref6.ref.value;\n        return value;\n      });\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    var _options$0$ref = options[0].ref,\n        checked = _options$0$ref.checked,\n        value = _options$0$ref.value,\n        attributes = _options$0$ref.attributes;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || value === '' ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled) {\n  var field = fieldsRef.current[name];\n\n  if (field) {\n    var _field$ref = field.ref,\n        value = _field$ref.value,\n        disabled = _field$ref.disabled,\n        ref = field.ref;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nvar isEmptyObject = function isEmptyObject(value) {\n  return isObject(value) && !Object.keys(value).length;\n};\n\nvar isBoolean = function isBoolean(value) {\n  return typeof value === 'boolean';\n};\n\nfunction baseGet(object, updatePath) {\n  var path = updatePath.slice(0, -1);\n  var length = path.length;\n  var index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  var updatePath = isKey(path) ? [path] : stringToPath(path);\n  var childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  var key = updatePath[updatePath.length - 1];\n  var previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (var k = 0; k < updatePath.slice(0, -1).length; k++) {\n    var index = -1;\n    var objectRef = undefined;\n    var currentPaths = updatePath.slice(0, -(k + 1));\n    var currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      var item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || isArray(objectRef) && !objectRef.filter(function (data) {\n        return isObject(data) && !isEmptyObject(data) || isBoolean(data);\n      }).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nvar isSameRef = function isSameRef(fieldValue, ref) {\n  return fieldValue && fieldValue.ref === ref;\n};\n\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\n  var ref = field.ref,\n      _field$ref2 = field.ref,\n      name = _field$ref2.name,\n      type = _field$ref2.type;\n  var fieldRef = fieldsRef.current[name];\n\n  if (!shouldUnregister) {\n    var value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n\n    if (!isUndefined(value)) {\n      set(shallowFieldsStateRef.current, name, value);\n    }\n  }\n\n  if (!type) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    var options = fieldRef.options;\n\n    if (isArray(options) && options.length) {\n      filterOutFalsy(options).forEach(function (option, index) {\n        var ref = option.ref;\n\n        if (ref && isDetached(ref) && isSameRef(option, ref) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n          unset(options, \"[\".concat(index, \"]\"));\n        }\n      });\n\n      if (options && !filterOutFalsy(options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldRef, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n    delete fieldsRef.current[name];\n  }\n}\n\nvar isString = function isString(value) {\n  return typeof value === 'string';\n};\n\nvar isPrimitive = function isPrimitive(value) {\n  return isNullOrUndefined(value) || !isObjectType(value);\n};\n\nfunction deepMerge(target, source) {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (var key in source) {\n    var targetValue = target[key];\n    var sourceValue = source[key];\n\n    try {\n      if (isObject(targetValue) && isObject(sourceValue) || isArray(targetValue) && isArray(sourceValue)) {\n        target[key] = deepMerge(targetValue, sourceValue);\n      } else {\n        target[key] = sourceValue;\n      }\n    } catch (_a) {}\n  }\n\n  return target;\n}\n\nvar getFieldsValues = function getFieldsValues(fieldsRef, shallowFieldsStateRef, excludeDisabled, search) {\n  var output = {};\n\n  var _loop = function _loop(name) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : isArray(search) && search.find(function (data) {\n      return name.startsWith(data);\n    }))) {\n      output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\n    }\n  };\n\n  for (var name in fieldsRef.current) {\n    _loop(name);\n  }\n\n  return deepMerge(Object.assign({}, (shallowFieldsStateRef || {}).current || {}), transformToNestObject(output));\n};\n\nvar isSameError = function isSameError(error, currentError) {\n  return isObject(error) && isObject(currentError) && error.type === currentError.type && error.message === currentError.message && Object.keys(error.types || {}).length === Object.keys(currentError.types || {}).length && Object.entries(error.types || {}).every(function (_ref7) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n        key = _ref8[0],\n        value = _ref8[1];\n\n    return (currentError.types || {})[key] === value;\n  });\n};\n\nfunction shouldRenderBasedOnError(_ref9) {\n  var errors = _ref9.errors,\n      name = _ref9.name,\n      error = _ref9.error,\n      validFields = _ref9.validFields,\n      fieldsWithValidation = _ref9.fieldsWithValidation;\n  var isValid = isUndefined(error);\n  var previousError = get(errors, name);\n  return isValid && !!previousError || !isValid && !isSameError(previousError, error) || isValid && get(fieldsWithValidation, name) && !get(validFields, name);\n}\n\nvar isRegex = function isRegex(value) {\n  return value instanceof RegExp;\n};\n\nvar isValueMessage = function isValueMessage(value) {\n  return isObject(value) && !isRegex(value);\n};\n\nvar getValueAndMessage = function getValueAndMessage(validationData) {\n  return isValueMessage(validationData) ? validationData : {\n    value: validationData,\n    message: ''\n  };\n};\n\nvar isFunction = function isFunction(value) {\n  return typeof value === 'function';\n};\n\nvar isMessage = function isMessage(value) {\n  return isString(value) || isObject(value) && isValidElement(value);\n};\n\nfunction getValidateError(result, ref) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'validate';\n\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type: type,\n      message: isMessage(result) ? result : '',\n      ref: ref\n    };\n  }\n}\n\nvar appendErrors = function appendErrors(name, validateAllFieldCriteria, errors, type, message) {\n  if (validateAllFieldCriteria) {\n    var error = errors[name];\n    return Object.assign(Object.assign({}, error), {\n      types: Object.assign(Object.assign({}, error && error.types ? error.types : {}), _defineProperty({}, type, message || true))\n    });\n  }\n\n  return {};\n};\n\nvar validateField = /*#__PURE__*/function () {\n  var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fieldsRef, validateAllFieldCriteria, _ref10, shallowFieldsStateRef) {\n    var ref, _ref10$ref, type, value, options, required, maxLength, minLength, min, max, pattern, validate, fields, name, error, isRadio, isCheckBox, isRadioOrCheckbox, isEmpty, appendErrorsCurry, getMinMaxMessage, _ref12, requiredValue, requiredMessage, exceedMax, exceedMin, _getValueAndMessage, maxValue, maxMessage, _getValueAndMessage2, minValue, minMessage, valueNumber, valueDate, _getValueAndMessage3, maxLengthValue, maxLengthMessage, _getValueAndMessage4, minLengthValue, minLengthMessage, inputLength, _exceedMax, _exceedMin, _getValueAndMessage5, patternValue, patternMessage, fieldValue, validateRef, result, validateError, validationResult, _i, _Object$entries, _Object$entries$_i, key, validateFunction, validateResult, _validateError;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            ref = _ref10.ref, _ref10$ref = _ref10.ref, type = _ref10$ref.type, value = _ref10$ref.value, options = _ref10.options, required = _ref10.required, maxLength = _ref10.maxLength, minLength = _ref10.minLength, min = _ref10.min, max = _ref10.max, pattern = _ref10.pattern, validate = _ref10.validate;\n            fields = fieldsRef.current;\n            name = ref.name;\n            error = {};\n            isRadio = isRadioInput(ref);\n            isCheckBox = isCheckBoxInput(ref);\n            isRadioOrCheckbox = isRadio || isCheckBox;\n            isEmpty = value === '';\n            appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n            getMinMaxMessage = function getMinMaxMessage(exceedMax, maxLengthMessage, minLengthMessage) {\n              var maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;\n              var minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;\n              var message = exceedMax ? maxLengthMessage : minLengthMessage;\n              error[name] = Object.assign({\n                type: exceedMax ? maxType : minType,\n                message: message,\n                ref: ref\n              }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n            };\n\n            if (!(required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid))) {\n              _context.next = 16;\n              break;\n            }\n\n            _ref12 = isMessage(required) ? {\n              value: !!required,\n              message: required\n            } : getValueAndMessage(required), requiredValue = _ref12.value, requiredMessage = _ref12.message;\n\n            if (!requiredValue) {\n              _context.next = 16;\n              break;\n            }\n\n            error[name] = Object.assign({\n              type: INPUT_VALIDATION_RULES.required,\n              message: requiredMessage,\n              ref: isRadioOrCheckbox ? ((fields[name].options || [])[0] || {}).ref : ref\n            }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 16;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 16:\n            if (!(!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n              _context.next = 24;\n              break;\n            }\n\n            _getValueAndMessage = getValueAndMessage(max), maxValue = _getValueAndMessage.value, maxMessage = _getValueAndMessage.message;\n            _getValueAndMessage2 = getValueAndMessage(min), minValue = _getValueAndMessage2.value, minMessage = _getValueAndMessage2.message;\n\n            if (type === 'number' || !type && !isNaN(value)) {\n              valueNumber = ref.valueAsNumber || parseFloat(value);\n\n              if (!isNullOrUndefined(maxValue)) {\n                exceedMax = valueNumber > maxValue;\n              }\n\n              if (!isNullOrUndefined(minValue)) {\n                exceedMin = valueNumber < minValue;\n              }\n            } else {\n              valueDate = ref.valueAsDate || new Date(value);\n\n              if (isString(maxValue)) {\n                exceedMax = valueDate > new Date(maxValue);\n              }\n\n              if (isString(minValue)) {\n                exceedMin = valueDate < new Date(minValue);\n              }\n            }\n\n            if (!(exceedMax || exceedMin)) {\n              _context.next = 24;\n              break;\n            }\n\n            getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 24;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 24:\n            if (!(isString(value) && !isEmpty && (maxLength || minLength))) {\n              _context.next = 34;\n              break;\n            }\n\n            _getValueAndMessage3 = getValueAndMessage(maxLength), maxLengthValue = _getValueAndMessage3.value, maxLengthMessage = _getValueAndMessage3.message;\n            _getValueAndMessage4 = getValueAndMessage(minLength), minLengthValue = _getValueAndMessage4.value, minLengthMessage = _getValueAndMessage4.message;\n            inputLength = value.toString().length;\n            _exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n            _exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n            if (!(_exceedMax || _exceedMin)) {\n              _context.next = 34;\n              break;\n            }\n\n            getMinMaxMessage(!!_exceedMax, maxLengthMessage, minLengthMessage);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 34;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 34:\n            if (!(pattern && !isEmpty)) {\n              _context.next = 40;\n              break;\n            }\n\n            _getValueAndMessage5 = getValueAndMessage(pattern), patternValue = _getValueAndMessage5.value, patternMessage = _getValueAndMessage5.message;\n\n            if (!(isRegex(patternValue) && !patternValue.test(value))) {\n              _context.next = 40;\n              break;\n            }\n\n            error[name] = Object.assign({\n              type: INPUT_VALIDATION_RULES.pattern,\n              message: patternMessage,\n              ref: ref\n            }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 40;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 40:\n            if (!validate) {\n              _context.next = 73;\n              break;\n            }\n\n            fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n            validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n            if (!isFunction(validate)) {\n              _context.next = 54;\n              break;\n            }\n\n            _context.next = 46;\n            return validate(fieldValue);\n\n          case 46:\n            result = _context.sent;\n            validateError = getValidateError(result, validateRef);\n\n            if (!validateError) {\n              _context.next = 52;\n              break;\n            }\n\n            error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n            if (validateAllFieldCriteria) {\n              _context.next = 52;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 52:\n            _context.next = 73;\n            break;\n\n          case 54:\n            if (!isObject(validate)) {\n              _context.next = 73;\n              break;\n            }\n\n            validationResult = {};\n            _i = 0, _Object$entries = Object.entries(validate);\n\n          case 57:\n            if (!(_i < _Object$entries.length)) {\n              _context.next = 69;\n              break;\n            }\n\n            _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], validateFunction = _Object$entries$_i[1];\n\n            if (!(!isEmptyObject(validationResult) && !validateAllFieldCriteria)) {\n              _context.next = 61;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 69);\n\n          case 61:\n            _context.next = 63;\n            return validateFunction(fieldValue);\n\n          case 63:\n            validateResult = _context.sent;\n            _validateError = getValidateError(validateResult, validateRef, key);\n\n            if (_validateError) {\n              validationResult = Object.assign(Object.assign({}, _validateError), appendErrorsCurry(key, _validateError.message));\n\n              if (validateAllFieldCriteria) {\n                error[name] = validationResult;\n              }\n            }\n\n          case 66:\n            _i++;\n            _context.next = 57;\n            break;\n\n          case 69:\n            if (isEmptyObject(validationResult)) {\n              _context.next = 73;\n              break;\n            }\n\n            error[name] = Object.assign({\n              ref: validateRef\n            }, validationResult);\n\n            if (validateAllFieldCriteria) {\n              _context.next = 73;\n              break;\n            }\n\n            return _context.abrupt(\"return\", error);\n\n          case 73:\n            return _context.abrupt(\"return\", error);\n\n          case 74:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function validateField(_x, _x2, _x3, _x4) {\n    return _ref11.apply(this, arguments);\n  };\n}();\n\nvar getPath = function getPath(path, values) {\n  var getInnerPath = function getInnerPath(key, value, isObject) {\n    var pathWithIndex = isObject ? \"\".concat(path, \".\").concat(key) : \"\".concat(path, \"[\").concat(key, \"]\");\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return Object.entries(values).map(function (_ref13) {\n    var _ref14 = _slicedToArray(_ref13, 2),\n        key = _ref14[0],\n        value = _ref14[1];\n\n    return getInnerPath(key, value, isObject(values));\n  }).flat(Infinity);\n};\n\nvar assignWatchFields = function assignWatchFields(fieldValues, fieldName, watchFields, inputValue, isSingleField) {\n  var value;\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || isArray(value)) {\n      getPath(fieldName, value).forEach(function (name) {\n        return watchFields.add(name);\n      });\n    }\n  }\n\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\n\nvar skipValidation = function skipValidation(_ref15) {\n  var isOnBlur = _ref15.isOnBlur,\n      isOnChange = _ref15.isOnChange,\n      isOnTouch = _ref15.isOnTouch,\n      isTouched = _ref15.isTouched,\n      isReValidateOnBlur = _ref15.isReValidateOnBlur,\n      isReValidateOnChange = _ref15.isReValidateOnChange,\n      isBlurEvent = _ref15.isBlurEvent,\n      isSubmitted = _ref15.isSubmitted,\n      isOnAll = _ref15.isOnAll;\n\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar getFieldArrayParentName = function getFieldArrayParentName(name) {\n  return name.substring(0, name.indexOf('['));\n};\n\nfunction deepEqual() {\n  var object1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var object2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var keys1 = Object.keys(object1);\n  var keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (var _i2 = 0, _keys = keys1; _i2 < _keys.length; _i2++) {\n    var key = _keys[_i2];\n    var val1 = object1[key];\n    var val2 = object2[key];\n\n    if ((isObject(val1) || isArray(val1)) && (isObject(val2) || isArray(val2)) ? !deepEqual(val1, val2) : val1 !== val2) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar isMatchFieldArrayName = function isMatchFieldArrayName(name, searchName) {\n  return RegExp(\"^\".concat(searchName, \"[\\\\d+]\").replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\n};\n\nvar isNameInFieldArray = function isNameInFieldArray(names, name) {\n  return _toConsumableArray(names).some(function (current) {\n    return isMatchFieldArrayName(name, current);\n  });\n};\n\nvar isSelectInput = function isSelectInput(element) {\n  return element.type === \"\".concat(SELECT, \"-one\");\n};\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\n  var observer = new MutationObserver(function () {\n    for (var _i3 = 0, _Object$values = Object.values(fieldsRef.current); _i3 < _Object$values.length; _i3++) {\n      var field = _Object$values[_i3];\n\n      if (field && field.options) {\n        var _iterator = _createForOfIteratorHelper(field.options),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var option = _step.value;\n\n            if (option && option.ref && isDetached(option.ref)) {\n              removeFieldEventListenerAndRef(field);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nvar modeChecker = function modeChecker(mode) {\n  return {\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\n    isOnChange: mode === VALIDATION_MODE.onChange,\n    isOnAll: mode === VALIDATION_MODE.all,\n    isOnTouch: mode === VALIDATION_MODE.onTouched\n  };\n};\n\nvar isRadioOrCheckboxFunction = function isRadioOrCheckboxFunction(ref) {\n  return isRadioInput(ref) || isCheckBoxInput(ref);\n};\n\nvar isWindowUndefined = typeof window === UNDEFINED;\nvar isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);\nvar isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useForm() {\n  var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref16$mode = _ref16.mode,\n      mode = _ref16$mode === void 0 ? VALIDATION_MODE.onSubmit : _ref16$mode,\n      _ref16$reValidateMode = _ref16.reValidateMode,\n      reValidateMode = _ref16$reValidateMode === void 0 ? VALIDATION_MODE.onChange : _ref16$reValidateMode,\n      resolver = _ref16.resolver,\n      context = _ref16.context,\n      _ref16$defaultValues = _ref16.defaultValues,\n      defaultValues = _ref16$defaultValues === void 0 ? {} : _ref16$defaultValues,\n      _ref16$shouldFocusErr = _ref16.shouldFocusError,\n      shouldFocusError = _ref16$shouldFocusErr === void 0 ? true : _ref16$shouldFocusErr,\n      _ref16$shouldUnregist = _ref16.shouldUnregister,\n      shouldUnregister = _ref16$shouldUnregist === void 0 ? true : _ref16$shouldUnregist,\n      criteriaMode = _ref16.criteriaMode;\n\n  var fieldsRef = useRef({});\n  var fieldArrayDefaultValuesRef = useRef({});\n  var watchFieldsRef = useRef(new Set());\n  var useWatchFieldsRef = useRef({});\n  var useWatchRenderFunctionsRef = useRef({});\n  var fieldsWithValidationRef = useRef({});\n  var validFieldsRef = useRef({});\n  var defaultValuesRef = useRef(defaultValues);\n  var defaultValuesAtRenderRef = useRef({});\n  var isUnMount = useRef(false);\n  var isWatchAllRef = useRef(false);\n  var handleChangeRef = useRef();\n  var shallowFieldsStateRef = useRef(shouldUnregister ? {} : defaultValues);\n  var resetFieldArrayFunctionRef = useRef({});\n  var contextRef = useRef(context);\n  var resolverRef = useRef(resolver);\n  var fieldArrayNamesRef = useRef(new Set());\n  var modeRef = useRef(modeChecker(mode));\n  var _modeRef$current = modeRef.current,\n      isOnSubmit = _modeRef$current.isOnSubmit,\n      isOnTouch = _modeRef$current.isOnTouch;\n  var isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n\n  var _useState = useState({\n    isDirty: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {}\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      formState = _useState2[0],\n      setFormState = _useState2[1];\n\n  var readFormStateRef = useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  var formStateRef = useRef(formState);\n  var observerRef = useRef();\n  var _useRef$current = useRef(modeChecker(reValidateMode)).current,\n      isReValidateOnBlur = _useRef$current.isOnBlur,\n      isReValidateOnChange = _useRef$current.isOnChange;\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n  var updateFormState = useCallback(function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return !isUnMount.current && setFormState(Object.assign(Object.assign({}, formStateRef.current), state));\n  }, []);\n  var shouldRenderBaseOnError = useCallback(function (name, error) {\n    var shouldRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var isValid = arguments.length > 4 ? arguments[4] : undefined;\n    var shouldReRender = shouldRender || shouldRenderBasedOnError({\n      errors: formStateRef.current.errors,\n      error: error,\n      name: name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    var previousError = get(formStateRef.current.errors, name);\n\n    if (error) {\n      unset(validFieldsRef.current, name);\n      shouldReRender = shouldReRender || !previousError || !isSameError(previousError, error);\n      set(formStateRef.current.errors, name, error);\n    } else {\n      if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n        set(validFieldsRef.current, name, true);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      unset(formStateRef.current.errors, name);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender) || !isEmptyObject(state)) {\n      updateFormState(Object.assign(Object.assign(Object.assign({}, state), {\n        errors: formStateRef.current.errors\n      }), resolverRef.current ? {\n        isValid: !!isValid\n      } : {}));\n    }\n  }, []);\n  var setFieldValue = useCallback(function (_ref17, rawValue) {\n    var ref = _ref17.ref,\n        options = _ref17.options;\n    var value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(ref) && options) {\n      options.forEach(function (_ref18) {\n        var radioRef = _ref18.ref;\n        return radioRef.checked = radioRef.value === value;\n      });\n    } else if (isFileInput(ref) && !isString(value)) {\n      ref.files = value;\n    } else if (isMultipleSelect(ref)) {\n      _toConsumableArray(ref.options).forEach(function (selectRef) {\n        return selectRef.selected = value.includes(selectRef.value);\n      });\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(function (_ref19) {\n        var checkboxRef = _ref19.ref;\n        return checkboxRef.checked = isArray(value) ? !!value.find(function (data) {\n          return data === checkboxRef.value;\n        }) : value === checkboxRef.value;\n      }) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, []);\n  var updateAndGetDirtyState = useCallback(function (name) {\n    var shouldRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!fieldsRef.current[name] || !readFormStateRef.current.isDirty && !readFormStateRef.current.dirtyFields) {\n      return {};\n    }\n\n    var isFieldDirty = defaultValuesAtRenderRef.current[name] !== getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n    var isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n    var isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    var previousIsDirty = formStateRef.current.isDirty;\n    isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);\n    var state = {\n      isDirty: isFieldArray && !deepEqual(get(getValues(), getFieldArrayParentName(name)), get(defaultValuesRef.current, getFieldArrayParentName(name))) || !isEmptyObject(formStateRef.current.dirtyFields),\n      dirtyFields: formStateRef.current.dirtyFields\n    };\n    var isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name);\n\n    if (isChanged && shouldRender) {\n      formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\n      updateFormState(Object.assign({}, state));\n    }\n\n    return isChanged ? state : {};\n  }, []);\n  var executeValidation = useCallback( /*#__PURE__*/function () {\n    var _ref20 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, skipReRender) {\n      var _error;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!fieldsRef.current[name]) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 3;\n              return validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef);\n\n            case 3:\n              _context2.t0 = name;\n              _error = _context2.sent[_context2.t0];\n              shouldRenderBaseOnError(name, _error, skipReRender);\n              return _context2.abrupt(\"return\", isUndefined(_error));\n\n            case 7:\n              return _context2.abrupt(\"return\", false);\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x5, _x6) {\n      return _ref20.apply(this, arguments);\n    };\n  }(), [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  var executeSchemaOrResolverValidation = useCallback( /*#__PURE__*/function () {\n    var _ref21 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(names) {\n      var _yield$resolverRef$cu, errors, previousFormIsValid, isInputsValid, _error2;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n\n            case 2:\n              _yield$resolverRef$cu = _context3.sent;\n              errors = _yield$resolverRef$cu.errors;\n              previousFormIsValid = formStateRef.current.isValid;\n\n              if (!isArray(names)) {\n                _context3.next = 11;\n                break;\n              }\n\n              isInputsValid = names.map(function (name) {\n                var error = get(errors, name);\n                error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);\n                return !error;\n              }).every(Boolean);\n              updateFormState({\n                isValid: isEmptyObject(errors),\n                errors: formStateRef.current.errors\n              });\n              return _context3.abrupt(\"return\", isInputsValid);\n\n            case 11:\n              _error2 = get(errors, names);\n              shouldRenderBaseOnError(names, _error2, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\n              return _context3.abrupt(\"return\", !_error2);\n\n            case 14:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x7) {\n      return _ref21.apply(this, arguments);\n    };\n  }(), [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  var trigger = useCallback( /*#__PURE__*/function () {\n    var _ref22 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(name) {\n      var fields, result;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              fields = name || Object.keys(fieldsRef.current);\n\n              if (!resolverRef.current) {\n                _context5.next = 3;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", executeSchemaOrResolverValidation(fields));\n\n            case 3:\n              if (!isArray(fields)) {\n                _context5.next = 9;\n                break;\n              }\n\n              _context5.next = 6;\n              return Promise.all(fields.map( /*#__PURE__*/function () {\n                var _ref23 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(data) {\n                  return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _context4.next = 2;\n                          return executeValidation(data, null);\n\n                        case 2:\n                          return _context4.abrupt(\"return\", _context4.sent);\n\n                        case 3:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                }));\n\n                return function (_x9) {\n                  return _ref23.apply(this, arguments);\n                };\n              }()));\n\n            case 6:\n              result = _context5.sent;\n              updateFormState();\n              return _context5.abrupt(\"return\", result.every(Boolean));\n\n            case 9:\n              _context5.next = 11;\n              return executeValidation(fields);\n\n            case 11:\n              return _context5.abrupt(\"return\", _context5.sent);\n\n            case 12:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function (_x8) {\n      return _ref22.apply(this, arguments);\n    };\n  }(), [executeSchemaOrResolverValidation, executeValidation]);\n  var setInternalValues = useCallback(function (name, value, _ref24) {\n    var shouldDirty = _ref24.shouldDirty,\n        shouldValidate = _ref24.shouldValidate;\n    getPath(name, value).forEach(function (fieldName) {\n      var data = {};\n      var field = fieldsRef.current[fieldName];\n\n      if (field) {\n        set(data, name, value);\n        setFieldValue(field, get(data, fieldName));\n\n        if (shouldDirty) {\n          updateAndGetDirtyState(fieldName);\n        }\n\n        if (shouldValidate) {\n          trigger(fieldName);\n        }\n      }\n    });\n  }, [trigger, setFieldValue, updateAndGetDirtyState]);\n  var setInternalValue = useCallback(function (name, value, config) {\n    if (fieldsRef.current[name]) {\n      setFieldValue(fieldsRef.current[name], value);\n      config.shouldDirty && updateAndGetDirtyState(name);\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value, config);\n\n      if (isNameInFieldArray(fieldArrayNamesRef.current, name) || fieldArrayNamesRef.current.has(name)) {\n        var fieldArrayParentName = getFieldArrayParentName(name) || name;\n        fieldArrayDefaultValuesRef.current[fieldArrayParentName] = value;\n        resetFieldArrayFunctionRef.current[fieldArrayParentName](_defineProperty({}, name, value));\n      }\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n  }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\n\n  var isFieldWatched = function isFieldWatched(name) {\n    return isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n  };\n\n  var renderWatchedInputs = function renderWatchedInputs(name) {\n    var found = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (var key in useWatchFieldsRef.current) {\n        if (!name || useWatchFieldsRef.current[key].has(name) || useWatchFieldsRef.current[key].has(getFieldArrayParentName(name)) || !useWatchFieldsRef.current[key].size) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(name, value) {\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    setInternalValue(name, value, config);\n\n    if (isFieldWatched(name)) {\n      updateFormState();\n    }\n\n    renderWatchedInputs(name);\n\n    if (config.shouldValidate) {\n      trigger(name);\n    }\n  }\n\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : /*#__PURE__*/function () {\n    var _ref26 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref25) {\n      var type, target, name, field, error, isValid, isBlurEvent, shouldSkipValidation, state, shouldRender, _yield$resolverRef$cu2, errors, previousFormIsValid;\n\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              type = _ref25.type, target = _ref25.target;\n              name = target.name;\n              field = fieldsRef.current[name];\n\n              if (!field) {\n                _context6.next = 29;\n                break;\n              }\n\n              isBlurEvent = type === EVENTS.BLUR;\n              shouldSkipValidation = skipValidation(Object.assign({\n                isBlurEvent: isBlurEvent,\n                isReValidateOnChange: isReValidateOnChange,\n                isReValidateOnBlur: isReValidateOnBlur,\n                isTouched: !!get(formStateRef.current.touched, name),\n                isSubmitted: formStateRef.current.isSubmitted\n              }, modeRef.current));\n              state = updateAndGetDirtyState(name, false);\n              shouldRender = !isEmptyObject(state) || isFieldWatched(name);\n\n              if (isBlurEvent && !get(formStateRef.current.touched, name) && readFormStateRef.current.touched) {\n                set(formStateRef.current.touched, name, true);\n                state = Object.assign(Object.assign({}, state), {\n                  touched: formStateRef.current.touched\n                });\n              }\n\n              if (!shouldSkipValidation) {\n                _context6.next = 12;\n                break;\n              }\n\n              renderWatchedInputs(name);\n              return _context6.abrupt(\"return\", (!isEmptyObject(state) || shouldRender && isEmptyObject(state)) && updateFormState(state));\n\n            case 12:\n              if (!resolverRef.current) {\n                _context6.next = 23;\n                break;\n              }\n\n              _context6.next = 15;\n              return resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n\n            case 15:\n              _yield$resolverRef$cu2 = _context6.sent;\n              errors = _yield$resolverRef$cu2.errors;\n              previousFormIsValid = formStateRef.current.isValid;\n              error = get(errors, name);\n              isValid = isEmptyObject(errors);\n\n              if (previousFormIsValid !== isValid) {\n                shouldRender = true;\n              }\n\n              _context6.next = 27;\n              break;\n\n            case 23:\n              _context6.next = 25;\n              return validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\n\n            case 25:\n              _context6.t0 = name;\n              error = _context6.sent[_context6.t0];\n\n            case 27:\n              renderWatchedInputs(name);\n              shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n\n            case 29:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n\n    return function (_x10) {\n      return _ref26.apply(this, arguments);\n    };\n  }();\n\n  function getValues(payload) {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (isArray(payload)) {\n      var data = {};\n\n      var _iterator2 = _createForOfIteratorHelper(payload),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _name = _step2.value;\n          set(data, _name, getFieldValue(fieldsRef, _name, shallowFieldsStateRef));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return data;\n    }\n\n    return getFieldsValues(fieldsRef, shallowFieldsStateRef);\n  }\n\n  var validateResolver = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n    var values,\n        _yield$resolverRef$cu3,\n        errors,\n        previousFormIsValid,\n        isValid,\n        _args7 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            values = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};\n            _context7.next = 3;\n            return resolverRef.current(Object.assign(Object.assign(Object.assign({}, defaultValuesRef.current), getValues()), values), contextRef.current, isValidateAllFieldCriteria);\n\n          case 3:\n            _yield$resolverRef$cu3 = _context7.sent;\n            errors = _yield$resolverRef$cu3.errors;\n            previousFormIsValid = formStateRef.current.isValid;\n            isValid = isEmptyObject(errors);\n\n            if (previousFormIsValid !== isValid) {\n              updateFormState({\n                isValid: isValid\n              });\n            }\n\n          case 8:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  })), [isValidateAllFieldCriteria]);\n  var removeFieldEventListener = useCallback(function (field, forceDelete) {\n    return findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete);\n  }, [shouldUnregister]);\n  var removeFieldEventListenerAndRef = useCallback(function (field, forceDelete) {\n    if (field) {\n      removeFieldEventListener(field, forceDelete);\n\n      if (shouldUnregister && !filterOutFalsy(field.options || []).length) {\n        delete defaultValuesAtRenderRef.current[field.ref.name];\n        unset(validFieldsRef.current, field.ref.name);\n        unset(fieldsWithValidationRef.current, field.ref.name);\n        unset(formStateRef.current.errors, field.ref.name);\n        unset(formStateRef.current.dirtyFields, field.ref.name);\n        unset(formStateRef.current.touched, field.ref.name);\n        updateFormState({\n          errors: formStateRef.current.errors,\n          isDirty: !isEmptyObject(formStateRef.current.dirtyFields),\n          dirtyFields: formStateRef.current.dirtyFields,\n          touched: formStateRef.current.touched\n        });\n        resolverRef.current && validateResolver();\n      }\n    }\n  }, [validateResolver, removeFieldEventListener]);\n\n  function clearErrors(name) {\n    name && (isArray(name) ? name : [name]).forEach(function (inputName) {\n      return fieldsRef.current[inputName] ? delete formStateRef.current.errors[inputName] : unset(formStateRef.current.errors, inputName);\n    });\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {}\n    });\n  }\n\n  function setError(name) {\n    var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var ref = (fieldsRef.current[name] || {}).ref;\n    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {\n      ref: ref\n    }));\n    updateFormState({\n      isValid: false,\n      errors: formStateRef.current.errors\n    });\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  var watchInternal = useCallback(function (fieldNames, defaultValue, watchId) {\n    var watchFields = watchId ? useWatchFieldsRef.current[watchId] : watchFieldsRef.current;\n    var combinedDefaultValues = isUndefined(defaultValue) ? defaultValuesRef.current : defaultValue;\n    var fieldValues = getFieldsValues(fieldsRef, shallowFieldsStateRef, false, fieldNames);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (fieldNames) {\n        var fieldRefNames = Object.keys(fieldsRef.current);\n\n        if (fieldRefNames.length) {\n          (isArray(fieldNames) ? fieldNames : [fieldNames]).forEach(function (name) {\n            if (!fieldRefNames.find(function (fieldName) {\n              return fieldName.startsWith(name);\n            })) {\n              console.warn(\"\\uD83D\\uDCCB watched fields: \".concat(fieldNames, \" are not found.\"));\n            }\n          });\n        }\n      }\n    }\n\n    if (isString(fieldNames)) {\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(defaultValue) ? get(combinedDefaultValues, fieldNames) : defaultValue, true);\n    }\n\n    if (isArray(fieldNames)) {\n      return fieldNames.reduce(function (previous, name) {\n        return Object.assign(Object.assign({}, previous), _defineProperty({}, name, assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)));\n      }, {});\n    }\n\n    if (isUndefined(watchId)) {\n      isWatchAllRef.current = true;\n    }\n\n    return transformToNestObject(!isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues);\n  }, []);\n\n  function watch(fieldNames, defaultValue) {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(name) {\n    (isArray(name) ? name : [name]).forEach(function (fieldName) {\n      return removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\n    });\n  }\n\n  function registerFieldRef(ref) {\n    var validateOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn(' Field is missing `name` attribute', ref, \"https://react-hook-form.com/api#useForm\");\n      }\n\n      if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) && !RegExp(\"^\".concat(ref.name.split(/\\[\\d+\\]$/)[0], \"[\\\\d+].\\\\w+\").replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(ref.name)) {\n        return console.warn(' `name` prop should be in object shape: name=\"test[index].name\"', ref, 'https://react-hook-form.com/api#useFieldArray');\n      }\n    }\n\n    var name = ref.name,\n        type = ref.type,\n        value = ref.value;\n    var fieldRefAndValidationOptions = Object.assign({\n      ref: ref\n    }, validateOptions);\n    var fields = fieldsRef.current;\n    var isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n\n    var compareRef = function compareRef(currentRef) {\n      return isWeb && (!isHTMLElement(ref) || currentRef === ref);\n    };\n\n    var field = fields[name];\n    var isEmptyDefaultValue = true;\n    var isFieldArray;\n    var defaultValue;\n\n    if (field && (isRadioOrCheckbox ? isArray(field.options) && filterOutFalsy(field.options).find(function (option) {\n      return value === option.ref.value && compareRef(option.ref);\n    }) : compareRef(field.ref))) {\n      fields[name] = Object.assign(Object.assign({}, field), validateOptions);\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [].concat(_toConsumableArray(filterOutFalsy(field && field.options || [])), [{\n          ref: ref\n        }]),\n        ref: {\n          type: type,\n          name: name\n        }\n      }, validateOptions) : Object.assign({}, fieldRefAndValidationOptions);\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n    var isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(isEmptyUnmountFields ? defaultValuesRef.current : shallowFieldsStateRef.current, name);\n      isEmptyDefaultValue = isUndefined(defaultValue);\n      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(field, defaultValue);\n      }\n    }\n\n    if (resolver && !isFieldArray && readFormStateRef.current.isValid) {\n      validateResolver();\n    } else if (!isEmptyObject(validateOptions)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then(function (error) {\n          var previousFormIsValid = formStateRef.current.isValid;\n          isEmptyObject(error) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);\n\n          if (previousFormIsValid !== isEmptyObject(error)) {\n            updateFormState();\n          }\n        });\n      }\n    }\n\n    if (!defaultValuesAtRenderRef.current[name] && !(isFieldArray && isEmptyDefaultValue)) {\n      var fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n      defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? isObject(fieldValue) ? Object.assign({}, fieldValue) : fieldValue : defaultValue;\n    }\n\n    if (type) {\n      attachEventListeners(isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\n    }\n  }\n\n  function register(refOrValidationOptions, rules) {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldRef({\n          name: refOrValidationOptions\n        }, rules);\n      } else if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\n        registerFieldRef(refOrValidationOptions, rules);\n      } else {\n        return function (ref) {\n          return ref && registerFieldRef(ref, refOrValidationOptions);\n        };\n      }\n    }\n  }\n\n  var handleSubmit = useCallback(function (onValid, onInvalid) {\n    return /*#__PURE__*/function () {\n      var _ref28 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(e) {\n        var fieldErrors, fieldValues, _yield$resolverRef$cu4, errors, values, _i4, _Object$values2, field, _name2, fieldError;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (e && e.preventDefault) {\n                  e.preventDefault();\n                  e.persist();\n                }\n\n                fieldErrors = {};\n                fieldValues = getFieldsValues(fieldsRef, shallowFieldsStateRef, true);\n\n                if (readFormStateRef.current.isSubmitting) {\n                  updateFormState({\n                    isSubmitting: true\n                  });\n                }\n\n                _context8.prev = 4;\n\n                if (!resolverRef.current) {\n                  _context8.next = 16;\n                  break;\n                }\n\n                _context8.next = 8;\n                return resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\n\n              case 8:\n                _yield$resolverRef$cu4 = _context8.sent;\n                errors = _yield$resolverRef$cu4.errors;\n                values = _yield$resolverRef$cu4.values;\n                formStateRef.current.errors = errors;\n                fieldErrors = errors;\n                fieldValues = values;\n                _context8.next = 28;\n                break;\n\n              case 16:\n                _i4 = 0, _Object$values2 = Object.values(fieldsRef.current);\n\n              case 17:\n                if (!(_i4 < _Object$values2.length)) {\n                  _context8.next = 28;\n                  break;\n                }\n\n                field = _Object$values2[_i4];\n\n                if (!field) {\n                  _context8.next = 25;\n                  break;\n                }\n\n                _name2 = field.ref.name;\n                _context8.next = 23;\n                return validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\n\n              case 23:\n                fieldError = _context8.sent;\n\n                if (fieldError[_name2]) {\n                  set(fieldErrors, _name2, fieldError[_name2]);\n                  unset(validFieldsRef.current, _name2);\n                } else if (get(fieldsWithValidationRef.current, _name2)) {\n                  unset(formStateRef.current.errors, _name2);\n                  set(validFieldsRef.current, _name2, true);\n                }\n\n              case 25:\n                _i4++;\n                _context8.next = 17;\n                break;\n\n              case 28:\n                if (!(isEmptyObject(fieldErrors) && Object.keys(formStateRef.current.errors).every(function (name) {\n                  return name in fieldsRef.current;\n                }))) {\n                  _context8.next = 34;\n                  break;\n                }\n\n                updateFormState({\n                  errors: {},\n                  isSubmitting: true\n                });\n                _context8.next = 32;\n                return onValid(fieldValues, e);\n\n              case 32:\n                _context8.next = 39;\n                break;\n\n              case 34:\n                formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\n\n                if (!onInvalid) {\n                  _context8.next = 38;\n                  break;\n                }\n\n                _context8.next = 38;\n                return onInvalid(fieldErrors, e);\n\n              case 38:\n                if (shouldFocusError) {\n                  focusOnErrorField(fieldsRef.current, fieldErrors);\n                }\n\n              case 39:\n                _context8.prev = 39;\n                updateFormState({\n                  isSubmitted: true,\n                  isSubmitting: false,\n                  isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n                  errors: formStateRef.current.errors,\n                  submitCount: formStateRef.current.submitCount + 1\n                });\n                return _context8.finish(39);\n\n              case 42:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[4,, 39, 42]]);\n      }));\n\n      return function (_x11) {\n        return _ref28.apply(this, arguments);\n      };\n    }();\n  }, [shouldFocusError, isValidateAllFieldCriteria]);\n\n  var resetRefs = function resetRefs(_ref29) {\n    var errors = _ref29.errors,\n        isDirty = _ref29.isDirty,\n        isSubmitted = _ref29.isSubmitted,\n        touched = _ref29.touched,\n        isValid = _ref29.isValid,\n        submitCount = _ref29.submitCount,\n        dirtyFields = _ref29.dirtyFields;\n\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    updateFormState({\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isSubmitting: false,\n      isSubmitSuccessful: false,\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isValid: isValid ? formStateRef.current.isValid : true,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {}\n    });\n  };\n\n  var reset = function reset(values) {\n    var omitResetState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (isWeb) {\n      for (var _i5 = 0, _Object$values3 = Object.values(fieldsRef.current); _i5 < _Object$values3.length; _i5++) {\n        var field = _Object$values3[_i5];\n\n        if (field) {\n          var _ref30 = field.ref,\n              options = field.options;\n          var inputRef = isRadioOrCheckboxFunction(_ref30) && isArray(options) ? options[0].ref : _ref30;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = values || Object.assign({}, defaultValuesRef.current);\n\n    if (values) {\n      renderWatchedInputs('');\n    }\n\n    shallowFieldsStateRef.current = shouldUnregister ? {} : values || {};\n    Object.values(resetFieldArrayFunctionRef.current).forEach(function (resetFieldArray) {\n      return isFunction(resetFieldArray) && resetFieldArray();\n    });\n    resetRefs(omitResetState);\n  };\n\n  observerRef.current = observerRef.current || !isWeb ? observerRef.current : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n  useEffect(function () {\n    isUnMount.current = false;\n    return function () {\n      isUnMount.current = true;\n\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      fieldsRef.current && Object.values(fieldsRef.current).forEach(function (field) {\n        return removeFieldEventListenerAndRef(field, true);\n      });\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors);\n  }\n\n  var commonProps = {\n    trigger: trigger,\n    setValue: useCallback(setValue, [setInternalValue, trigger]),\n    getValues: useCallback(getValues, []),\n    register: useCallback(register, [defaultValuesRef.current]),\n    unregister: useCallback(unregister, [])\n  };\n  var control = Object.assign({\n    removeFieldEventListener: removeFieldEventListener,\n    renderWatchedInputs: renderWatchedInputs,\n    watchInternal: watchInternal,\n    mode: modeRef.current,\n    reValidateMode: {\n      isReValidateOnBlur: isReValidateOnBlur,\n      isReValidateOnChange: isReValidateOnChange\n    },\n    fieldsRef: fieldsRef,\n    isWatchAllRef: isWatchAllRef,\n    watchFieldsRef: watchFieldsRef,\n    resetFieldArrayFunctionRef: resetFieldArrayFunctionRef,\n    useWatchFieldsRef: useWatchFieldsRef,\n    useWatchRenderFunctionsRef: useWatchRenderFunctionsRef,\n    fieldArrayDefaultValuesRef: fieldArrayDefaultValuesRef,\n    validFieldsRef: validFieldsRef,\n    fieldsWithValidationRef: fieldsWithValidationRef,\n    fieldArrayNamesRef: fieldArrayNamesRef,\n    readFormStateRef: readFormStateRef,\n    formStateRef: formStateRef,\n    defaultValuesRef: defaultValuesRef,\n    shallowFieldsStateRef: shallowFieldsStateRef,\n    updateFormState: updateFormState,\n    shouldUnregister: shouldUnregister,\n    validateResolver: resolver ? validateResolver : undefined\n  }, commonProps);\n  return Object.assign({\n    watch: watch,\n    control: control,\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: function get(obj, prop) {\n        if (process.env.NODE_ENV !== 'production' && prop === 'isValid' && isOnSubmit) {\n          console.warn(' `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\n        }\n\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n\n        return undefined;\n      }\n    }) : formState,\n    handleSubmit: handleSubmit,\n    reset: useCallback(reset, []),\n    clearErrors: useCallback(clearErrors, []),\n    setError: useCallback(setError, []),\n    errors: formState.errors\n  }, commonProps);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nvar FormContext = createContext(null);\nFormContext.displayName = 'RHFContext';\n\nvar useFormContext = function useFormContext() {\n  return useContext(FormContext);\n};\n\nvar FormProvider = function FormProvider(_a) {\n  var children = _a.children,\n      props = __rest(_a, [\"children\"]);\n\n  return createElement(FormContext.Provider, {\n    value: Object.assign({}, props)\n  }, children);\n};\n\nvar generateId = function generateId() {\n  var d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nvar removeAt = function removeAt(data, index) {\n  return [].concat(_toConsumableArray(data.slice(0, index)), _toConsumableArray(data.slice(index + 1)));\n};\n\nfunction removeAtIndexes(data, index) {\n  var k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return filterOutFalsy(data);\n}\n\nvar removeArrayAt = function removeArrayAt(data, index) {\n  return isUndefined(index) ? [] : isArray(index) ? removeAtIndexes(data, index) : removeAt(data, index);\n};\n\nvar moveArrayAt = function moveArrayAt(data, from, to) {\n  if (isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n\nvar swapArrayAt = function swapArrayAt(data, indexA, indexB) {\n  var temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n\nfunction prepend(data, value) {\n  return [].concat(_toConsumableArray(isArray(value) ? value : [value || undefined]), _toConsumableArray(data));\n}\n\nfunction insert(data, index, value) {\n  return [].concat(_toConsumableArray(data.slice(0, index)), _toConsumableArray(isArray(value) ? value : [value || undefined]), _toConsumableArray(data.slice(index)));\n}\n\nvar fillEmptyArray = function fillEmptyArray(value) {\n  return isArray(value) ? Array(value.length).fill(undefined) : undefined;\n};\n\nfunction mapValueToBoolean(value) {\n  if (isObject(value)) {\n    var object = {};\n\n    for (var key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nvar filterBooleanArray = function filterBooleanArray(value) {\n  return (isArray(value) ? value : [value]).map(mapValueToBoolean).flat();\n};\n\nvar appendId = function appendId(value, keyName) {\n  return Object.assign(_defineProperty({}, keyName, generateId()), value);\n};\n\nvar mapIds = function mapIds(data, keyName) {\n  return (isArray(data) ? data : []).map(function (value) {\n    return appendId(value, keyName);\n  });\n};\n\nvar useFieldArray = function useFieldArray(_ref31) {\n  var control = _ref31.control,\n      name = _ref31.name,\n      _ref31$keyName = _ref31.keyName,\n      keyName = _ref31$keyName === void 0 ? 'id' : _ref31$keyName;\n  var methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(' useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray');\n    }\n\n    if (!name) {\n      console.warn(' useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray');\n    }\n  }\n\n  var focusIndexRef = useRef(-1);\n\n  var _ref32 = control || methods.control,\n      isWatchAllRef = _ref32.isWatchAllRef,\n      resetFieldArrayFunctionRef = _ref32.resetFieldArrayFunctionRef,\n      fieldArrayNamesRef = _ref32.fieldArrayNamesRef,\n      fieldsRef = _ref32.fieldsRef,\n      defaultValuesRef = _ref32.defaultValuesRef,\n      removeFieldEventListener = _ref32.removeFieldEventListener,\n      formStateRef = _ref32.formStateRef,\n      _ref32$formStateRef$c = _ref32.formStateRef.current,\n      dirtyFields = _ref32$formStateRef$c.dirtyFields,\n      touched = _ref32$formStateRef$c.touched,\n      shallowFieldsStateRef = _ref32.shallowFieldsStateRef,\n      updateFormState = _ref32.updateFormState,\n      readFormStateRef = _ref32.readFormStateRef,\n      watchFieldsRef = _ref32.watchFieldsRef,\n      validFieldsRef = _ref32.validFieldsRef,\n      fieldsWithValidationRef = _ref32.fieldsWithValidationRef,\n      fieldArrayDefaultValuesRef = _ref32.fieldArrayDefaultValuesRef,\n      validateResolver = _ref32.validateResolver,\n      renderWatchedInputs = _ref32.renderWatchedInputs,\n      getValues = _ref32.getValues;\n\n  var fieldArrayParentName = getFieldArrayParentName(name);\n\n  var getDefaultValues = function getDefaultValues() {\n    return _toConsumableArray(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName) ? get(fieldArrayDefaultValuesRef.current, name, []) : get(defaultValuesRef.current, name, []));\n  };\n\n  var memoizedDefaultValues = useRef(getDefaultValues());\n\n  var _useState3 = useState(mapIds(memoizedDefaultValues.current, keyName)),\n      _useState4 = _slicedToArray(_useState3, 2),\n      fields = _useState4[0],\n      setFields = _useState4[1];\n\n  var allFields = useRef(fields);\n\n  var getCurrentFieldsValues = function getCurrentFieldsValues() {\n    return get(getValues() || {}, name, allFields.current).map(function (item, index) {\n      return Object.assign(Object.assign({}, allFields.current[index]), item);\n    });\n  };\n\n  allFields.current = fields;\n  fieldArrayNamesRef.current.add(name);\n\n  if (!get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\n    set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, get(defaultValuesRef.current, fieldArrayParentName));\n  }\n\n  var appendValueWithKey = function appendValueWithKey(values) {\n    return values.map(function (value) {\n      return appendId(value, keyName);\n    });\n  };\n\n  var setFieldAndValidState = function setFieldAndValidState(fieldsValues) {\n    setFields(fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      var values = {};\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  var getIsDirtyState = function getIsDirtyState(flagOrFields) {\n    return (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && (isUndefined(flagOrFields) || !deepEqual(flagOrFields.map(function () {\n      var _a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _b = keyName,\n          omitted = _a[_b],\n          rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n      return rest;\n    }), get(defaultValuesRef.current, name)));\n  };\n\n  var resetFields = function resetFields() {\n    for (var key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\n        removeFieldEventListener(fieldsRef.current[key], true);\n      }\n    }\n  };\n\n  var cleanup = function cleanup(ref) {\n    return !filterOutFalsy(get(ref, name, [])).length && unset(ref, name);\n  };\n\n  var batchStateUpdate = function batchStateUpdate(method, args) {\n    var isDirty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var shouldSet = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldUpdateValid = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    if (get(shallowFieldsStateRef.current, name)) {\n      var output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n      cleanup(shallowFieldsStateRef.current);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      var _output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\n\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, _output);\n      cleanup(fieldArrayDefaultValuesRef.current);\n    }\n\n    if (isArray(get(formStateRef.current.errors, name))) {\n      var _output2 = method(get(formStateRef.current.errors, name), args.argA, args.argB);\n\n      shouldSet && set(formStateRef.current.errors, name, _output2);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touched && get(touched, name)) {\n      var _output3 = method(get(touched, name), args.argA, args.argB);\n\n      shouldSet && set(touched, name, _output3);\n      cleanup(touched);\n    }\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      var _output4 = method(get(dirtyFields, name, []), args.argC, args.argD);\n\n      shouldSet && set(dirtyFields, name, _output4);\n      cleanup(dirtyFields);\n    }\n\n    if (shouldUpdateValid && readFormStateRef.current.isValid && !validateResolver) {\n      set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\n      cleanup(validFieldsRef.current);\n      set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    updateFormState({\n      errors: formStateRef.current.errors,\n      dirtyFields: dirtyFields,\n      isDirty: isDirty,\n      touched: touched\n    });\n  };\n\n  var append = function append(value) {\n    var shouldFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    setFieldAndValidState([].concat(_toConsumableArray(allFields.current), _toConsumableArray(isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)])));\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      set(dirtyFields, name, [].concat(_toConsumableArray(isArray(get(dirtyFields, name)) ? get(dirtyFields, name) : fillEmptyArray(allFields.current)), _toConsumableArray(filterBooleanArray(value))));\n      updateFormState({\n        isDirty: true,\n        dirtyFields: dirtyFields\n      });\n    }\n\n    focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\n    renderWatchedInputs(name);\n  };\n\n  var prepend$1 = function prepend$1(value) {\n    var shouldFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var emptyArray = fillEmptyArray(value);\n    setFieldAndValidState(prepend(getCurrentFieldsValues(), isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n    resetFields();\n    batchStateUpdate(prepend, {\n      argA: emptyArray,\n      argC: filterBooleanArray(value)\n    });\n    renderWatchedInputs(name);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  var remove = function remove(index) {\n    var fieldValues = getCurrentFieldsValues();\n    setFieldAndValidState(removeArrayAt(fieldValues, index));\n    resetFields();\n    batchStateUpdate(removeArrayAt, {\n      argA: index,\n      argC: index\n    }, getIsDirtyState(removeArrayAt(fieldValues, index)), true, true);\n    renderWatchedInputs(name);\n  };\n\n  var insert$1 = function insert$1(index, value) {\n    var shouldFocus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var emptyArray = fillEmptyArray(value);\n    var fieldValues = getCurrentFieldsValues();\n    setFieldAndValidState(insert(fieldValues, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n    resetFields();\n    batchStateUpdate(insert, {\n      argA: index,\n      argB: emptyArray,\n      argC: index,\n      argD: filterBooleanArray(value)\n    }, getIsDirtyState(insert(fieldValues, index)));\n    renderWatchedInputs(name);\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  var swap = function swap(indexA, indexB) {\n    var fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState(_toConsumableArray(fieldValues));\n    batchStateUpdate(swapArrayAt, {\n      argA: indexA,\n      argB: indexB,\n      argC: indexA,\n      argD: indexB\n    }, getIsDirtyState(fieldValues), false);\n    renderWatchedInputs(name);\n  };\n\n  var move = function move(from, to) {\n    var fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState(_toConsumableArray(fieldValues));\n    batchStateUpdate(moveArrayAt, {\n      argA: from,\n      argB: to,\n      argC: from,\n      argD: to\n    }, getIsDirtyState(fieldValues), false);\n    renderWatchedInputs(name);\n  };\n\n  var reset = function reset(data) {\n    resetFields();\n    !data && unset(fieldArrayDefaultValuesRef.current, name);\n    unset(shallowFieldsStateRef.current, name);\n    memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\n    setFields(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  useEffect(function () {\n    var defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      defaultValues.pop();\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues);\n    }\n\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else if (watchFieldsRef) {\n      var shouldRenderUseWatch = true;\n\n      var _iterator3 = _createForOfIteratorHelper(watchFieldsRef.current),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var watchField = _step3.value;\n\n          if (watchField.startsWith(name)) {\n            updateFormState();\n            shouldRenderUseWatch = false;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      shouldRenderUseWatch && renderWatchedInputs(name);\n    }\n\n    if (focusIndexRef.current > -1) {\n      for (var key in fieldsRef.current) {\n        var field = fieldsRef.current[key];\n\n        if (key.startsWith(\"\".concat(name, \"[\").concat(focusIndexRef.current, \"]\")) && field.ref.focus) {\n          field.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n  useEffect(function () {\n    var resetFunctions = resetFieldArrayFunctionRef.current;\n    var fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = reset;\n    }\n\n    return function () {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [name]),\n    insert: useCallback(insert$1, [name]),\n    fields: fields\n  };\n};\n\nfunction useWatch(_ref33) {\n  var control = _ref33.control,\n      name = _ref33.name,\n      defaultValue = _ref33.defaultValue;\n  var methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(' useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch');\n    }\n\n    if (name === '') {\n      console.warn(' useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch');\n    }\n  }\n\n  var _ref34 = control || methods.control,\n      useWatchFieldsRef = _ref34.useWatchFieldsRef,\n      useWatchRenderFunctionsRef = _ref34.useWatchRenderFunctionsRef,\n      watchInternal = _ref34.watchInternal,\n      defaultValuesRef = _ref34.defaultValuesRef;\n\n  var _useState5 = useState(isUndefined(defaultValue) ? isString(name) ? get(defaultValuesRef.current, name) : isArray(name) ? name.reduce(function (previous, inputName) {\n    return Object.assign(Object.assign({}, previous), _defineProperty({}, inputName, get(defaultValuesRef.current, inputName)));\n  }, {}) : defaultValuesRef.current : defaultValue),\n      _useState6 = _slicedToArray(_useState5, 2),\n      value = _useState6[0],\n      setValue = _useState6[1];\n\n  var idRef = useRef();\n  var defaultValueRef = useRef(defaultValue);\n  var updateWatchValue = useCallback(function () {\n    var value = watchInternal(name, defaultValueRef.current, idRef.current);\n    setValue(isObject(value) ? Object.assign({}, value) : isArray(value) ? _toConsumableArray(value) : value);\n  }, [setValue, watchInternal, defaultValueRef, name, idRef]);\n  useEffect(function () {\n    var id = idRef.current = generateId();\n    var watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    var watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(name, defaultValueRef.current, id);\n    return function () {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [name, updateWatchValue, useWatchRenderFunctionsRef, useWatchFieldsRef, watchInternal, defaultValueRef]);\n  return isUndefined(value) ? defaultValue : value;\n}\n\nvar getInputValue = function getInputValue(event) {\n  return isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isUndefined(event.target.value) ? event.target.checked : event.target.value;\n};\n\nvar Controller = function Controller(_a) {\n  var name = _a.name,\n      rules = _a.rules,\n      as = _a.as,\n      render = _a.render,\n      defaultValue = _a.defaultValue,\n      control = _a.control,\n      onFocus = _a.onFocus,\n      rest = __rest(_a, [\"name\", \"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\n\n  var methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production' && !control && !methods) {\n    throw new Error(' Controller is missing `control` prop. https://react-hook-form.com/api#Controller');\n  }\n\n  var _ref35 = control || methods.control,\n      defaultValuesRef = _ref35.defaultValuesRef,\n      setValue = _ref35.setValue,\n      register = _ref35.register,\n      unregister = _ref35.unregister,\n      trigger = _ref35.trigger,\n      mode = _ref35.mode,\n      _ref35$reValidateMode = _ref35.reValidateMode,\n      isReValidateOnBlur = _ref35$reValidateMode.isReValidateOnBlur,\n      isReValidateOnChange = _ref35$reValidateMode.isReValidateOnChange,\n      _ref35$formStateRef$c = _ref35.formStateRef.current,\n      isSubmitted = _ref35$formStateRef$c.isSubmitted,\n      touched = _ref35$formStateRef$c.touched,\n      updateFormState = _ref35.updateFormState,\n      readFormStateRef = _ref35.readFormStateRef,\n      fieldsRef = _ref35.fieldsRef,\n      fieldArrayNamesRef = _ref35.fieldArrayNamesRef,\n      shallowFieldsStateRef = _ref35.shallowFieldsStateRef;\n\n  var isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n  var getInitialValue = function getInitialValue() {\n    return !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray ? get(shallowFieldsStateRef.current, name) : isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue;\n  };\n\n  var _useState7 = useState(getInitialValue()),\n      _useState8 = _slicedToArray(_useState7, 2),\n      value = _useState8[0],\n      setInputStateValue = _useState8[1];\n\n  var valueRef = useRef(value);\n  var onFocusRef = useRef(onFocus);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined(value)) {\n      console.warn(\"\\uD83D\\uDCCB \".concat(name, \" is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)\"));\n    }\n\n    if (!as && !render || as && render) {\n      console.warn(\"\\uD83D\\uDCCB \".concat(name, \" Controller should use either the 'as' or 'render' prop, not both. https://react-hook-form.com/api#Controller\"));\n    }\n\n    if (!isNotFieldArray && isUndefined(defaultValue)) {\n      console.warn(' Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller');\n    }\n  }\n\n  var shouldValidate = function shouldValidate(isBlurEvent) {\n    return !skipValidation(Object.assign({\n      isBlurEvent: isBlurEvent,\n      isReValidateOnBlur: isReValidateOnBlur,\n      isReValidateOnChange: isReValidateOnChange,\n      isSubmitted: isSubmitted,\n      isTouched: !!get(touched, name)\n    }, mode));\n  };\n\n  var commonTask = function commonTask(_ref36) {\n    var _ref37 = _slicedToArray(_ref36, 1),\n        event = _ref37[0];\n\n    var data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  var registerField = useCallback(function () {\n    if (process.env.NODE_ENV !== 'production' && !name) {\n      return console.warn(' Field is missing `name` prop. https://react-hook-form.com/api#Controller');\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = Object.assign({\n        ref: fieldsRef.current[name].ref\n      }, rules);\n    } else {\n      register(Object.defineProperty({\n        name: name,\n        focus: onFocusRef.current\n      }, VALUE, {\n        set: function set(data) {\n          setInputStateValue(data);\n          valueRef.current = data;\n        },\n        get: function get() {\n          return valueRef.current;\n        }\n      }), rules);\n\n      if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  }, [rules, name, register]);\n  useEffect(function () {\n    return function () {\n      !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\n    };\n  }, [unregister, name, fieldArrayNamesRef]);\n  useEffect(function () {\n    registerField();\n  }, [registerField]);\n  useEffect(function () {\n    if (!fieldsRef.current[name]) {\n      registerField();\n\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  var onBlur = function onBlur() {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched: touched\n      });\n    }\n\n    if (shouldValidate(true)) {\n      trigger(name);\n    }\n  };\n\n  var onChange = function onChange() {\n    for (var _len = arguments.length, event = new Array(_len), _key = 0; _key < _len; _key++) {\n      event[_key] = arguments[_key];\n    }\n\n    return setValue(name, commonTask(event), {\n      shouldValidate: shouldValidate(),\n      shouldDirty: true\n    });\n  };\n\n  var props = Object.assign(Object.assign({}, rest), {\n    onChange: onChange,\n    onBlur: onBlur,\n    name: name,\n    value: value\n  });\n  return as ? isValidElement(as) ? cloneElement(as, props) : createElement(as, props) : render ? render({\n    onChange: onChange,\n    onBlur: onBlur,\n    value: value,\n    name: name\n  }) : null;\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useFieldArray, useForm, useFormContext, useWatch };","map":{"version":3,"sources":["../src/utils/isHTMLElement.ts","../src/constants.ts","../src/logic/attachEventListeners.ts","../src/utils/isNullOrUndefined.ts","../src/utils/isArray.ts","../src/utils/isObject.ts","../src/utils/isKey.ts","../src/utils/stringToPath.ts","../src/utils/set.ts","../src/logic/transformToNestObject.ts","../src/utils/isUndefined.ts","../src/utils/filterOutFalsy.ts","../src/utils/get.ts","../src/logic/focusOnErrorField.ts","../src/logic/removeAllEventListeners.ts","../src/logic/getRadioValue.ts","../src/logic/getMultipleSelectValue.ts","../src/utils/isRadioInput.ts","../src/utils/isFileInput.ts","../src/utils/isCheckBoxInput.ts","../src/utils/isMultipleSelect.ts","../src/logic/getCheckboxValue.ts","../src/logic/getFieldValue.ts","../src/utils/isDetached.ts","../src/utils/isEmptyObject.ts","../src/utils/isBoolean.ts","../src/utils/unset.ts","../src/logic/findRemovedFieldAndRemoveListener.ts","../src/utils/isString.ts","../src/utils/isPrimitive.ts","../src/utils/deepMerge.ts","../src/logic/getFieldsValues.ts","../src/utils/isSameError.ts","../src/logic/shouldRenderBasedOnError.ts","../src/utils/isRegex.ts","../src/logic/getValueAndMessage.ts","../src/utils/isFunction.ts","../src/utils/isMessage.ts","../src/logic/getValidateError.ts","../src/logic/appendErrors.ts","../src/logic/validateField.ts","../src/utils/getPath.ts","../src/logic/assignWatchFields.ts","../src/logic/skipValidation.ts","../src/logic/getFieldArrayParentName.ts","../src/utils/deepEqual.ts","../src/logic/isNameInFieldArray.ts","../src/utils/isSelectInput.ts","../src/utils/onDomRemove.ts","../src/utils/validationModeChecker.ts","../src/utils/isRadioOrCheckbox.ts","../src/useForm.ts","../src/useFormContext.tsx","../src/logic/generateId.ts","../src/utils/remove.ts","../src/utils/move.ts","../src/utils/swap.ts","../src/utils/prepend.ts","../src/utils/insert.ts","../src/utils/fillEmptyArray.ts","../src/utils/filterBooleanArray.ts","../src/useFieldArray.ts","../src/useWatch.ts","../src/logic/getInputValue.ts","../src/controller.tsx"],"names":["isCheckBox","getFieldsValue","React.useRef","React.useState","React.useCallback","React.useEffect","React.createContext","React.useContext","React.createElement","prepend","prependAt","insert","insertAt","React.isValidElement","React.cloneElement"],"mappings":"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","sourcesContent":["export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { ValidationMode } from './types';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all',\n};\n\nexport const VALUE = 'value';\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Field } from '../types';\n\nexport default function attachEventListeners(\n  { ref }: Field,\n  shouldAttachChangeEvent?: boolean,\n  handleChange?: EventListenerOrEventListenerObject,\n): void {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(\n      shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT,\n      handleChange,\n    );\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n","export default (value: unknown): value is null | undefined => value == null;\n","export default <T>(value: unknown): value is T[] => Array.isArray(value);\n","import isNullOrUndefined from './isNullOrUndefined';\nimport isArray from './isArray';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !isArray(value) &&\n  isObjectType(value) &&\n  !(value instanceof Date);\n","import isArray from './isArray';\n\nexport default (value: [] | string) =>\n  !isArray(value) &&\n  (/^\\w*$/.test(value) ||\n    !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n","export default (input: string): (string | number)[] => {\n  const result: (string | number)[] = [];\n\n  input.replace(\n    /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n    (\n      match: string,\n      mathNumber: string,\n      mathQuote: string,\n      originalString: string,\n    ): any => {\n      result.push(\n        mathQuote\n          ? originalString.replace(/\\\\(\\\\)?/g, '$1')\n          : mathNumber || match,\n      );\n    },\n  );\n\n  return result;\n};\n","import isObject from './isObject';\nimport isArray from './isArray';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport { FieldValues } from '../types';\n\nexport default function set(object: FieldValues, path: string, value: unknown) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import set from '../utils/set';\nimport isKey from '../utils/isKey';\nimport { FieldValues } from '../types';\n\nexport default (data: FieldValues): any =>\n  Object.entries(data).reduce(\n    (previous: FieldValues, [key, value]): FieldValues => {\n      if (!isKey(key)) {\n        set(previous, key, value);\n        return previous;\n      }\n\n      return { ...previous, [key]: value };\n    },\n    {},\n  );\n","export default (val: unknown): val is undefined => val === undefined;\n","export default (value: any[]) => value.filter(Boolean);\n","import isUndefined from './isUndefined';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport filterOutFalsy from './filterOutFalsy';\n\nexport default (obj: any, path: string, defaultValue?: unknown) => {\n  const result = filterOutFalsy(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","import get from '../utils/get';\nimport { FieldErrors, FieldRefs } from '../types';\n\nexport default <TFieldValues>(\n  fields: FieldRefs<TFieldValues>,\n  fieldErrors: FieldErrors<TFieldValues>,\n) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          field.ref.focus();\n\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n\n          break;\n        }\n      }\n    }\n  }\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Ref } from '../types';\n\nexport default (\n  ref: Ref,\n  validateWithStateUpdate: EventListenerOrEventListenerObject,\n): void => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n","import isArray from '../utils/isArray';\nimport { RadioOrCheckboxOption } from '../types';\n\ntype RadioFieldResult = {\n  isValid: boolean;\n  value: number | string;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: '',\n};\n\nexport default (options?: RadioOrCheckboxOption[]): RadioFieldResult =>\n  isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.ref.checked\n            ? {\n                isValid: true,\n                value: option.ref.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","import isArray from '../utils/isArray';\nimport isUndefined from '../utils/isUndefined';\nimport { RadioOrCheckboxOption } from '../types';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: RadioOrCheckboxOption[]): CheckboxFieldResult => {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.ref.checked)\n        .map(({ ref: { value } }) => value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    const { checked, value, attributes } = options[0].ref;\n\n    return checked\n      ? attributes && !isUndefined((attributes as any).value)\n        ? isUndefined(value) || value === ''\n          ? validResult\n          : { value: value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport get from '../utils/get';\nimport isFileInput from '../utils/isFileInput';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport getCheckboxValue from './getCheckboxValue';\nimport { FieldRefs, FieldValues, InternalFieldName } from '../types';\n\nexport default function getFieldValue<TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  name: InternalFieldName<TFieldValues>,\n  shallowFieldsStateRef?: React.MutableRefObject<FieldValues>,\n  excludeDisabled?: boolean,\n) {\n  const field = fieldsRef.current[name]!;\n\n  if (field) {\n    const {\n      ref: { value, disabled },\n      ref,\n    } = field;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n","import { Ref } from '../types';\n\nexport default function isDetached(element: Ref): boolean {\n  if (!element) {\n    return true;\n  }\n\n  if (\n    !(element instanceof HTMLElement) ||\n    element.nodeType === Node.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n\n  return isDetached(element.parentNode as Ref);\n}\n","import isObject from './isObject';\nimport { EmptyObject } from '../types';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import isArray from './isArray';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport isEmptyObject from './isEmptyObject';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\nimport isBoolean from './isBoolean';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const path = updatePath.slice(0, -1);\n  const length = path.length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (isArray(objectRef) &&\n            !objectRef.filter(\n              (data) =>\n                (isObject(data) && !isEmptyObject(data)) || isBoolean(data),\n            ).length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import * as React from 'react';\nimport removeAllEventListeners from './removeAllEventListeners';\nimport getFieldValue from './getFieldValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport set from '../utils/set';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isDetached from '../utils/isDetached';\nimport isArray from '../utils/isArray';\nimport unset from '../utils/unset';\nimport filterOutFalsy from '../utils/filterOutFalsy';\nimport isUndefined from '../utils/isUndefined';\nimport { Field, FieldRefs, FieldValues, Ref } from '../types';\n\nconst isSameRef = (fieldValue: Field, ref: Ref) =>\n  fieldValue && fieldValue.ref === ref;\n\nexport default function findRemovedFieldAndRemoveListener<\n  TFieldValues extends FieldValues\n>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  handleChange: ({ type, target }: Event) => Promise<void | boolean>,\n  field: Field,\n  shallowFieldsStateRef: React.MutableRefObject<FieldValues>,\n  shouldUnregister?: boolean,\n  forceDelete?: boolean,\n): void {\n  const {\n    ref,\n    ref: { name, type },\n  } = field;\n  const fieldRef = fieldsRef.current[name] as Field;\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n\n    if (!isUndefined(value)) {\n      set(shallowFieldsStateRef.current, name, value);\n    }\n  }\n\n  if (!type) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    const { options } = fieldRef;\n\n    if (isArray(options) && options.length) {\n      filterOutFalsy(options).forEach((option, index): void => {\n        const { ref } = option;\n        if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n          unset(options, `[${index}]`);\n        }\n      });\n\n      if (options && !filterOutFalsy(options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    delete fieldsRef.current[name];\n  }\n}\n","export default (value: unknown): value is string => typeof value === 'string';\n","import isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\nimport { Primitive } from '../types';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import isObject from './isObject';\nimport isArray from './isArray';\nimport isPrimitive from './isPrimitive';\n\nexport function deepMerge<\n  T extends Record<keyof T, any>,\n  U extends Record<keyof U, any>\n>(target: T, source: U): T & U {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      if (\n        (isObject(targetValue) && isObject(sourceValue)) ||\n        (isArray(targetValue) && isArray(sourceValue))\n      ) {\n        target[key] = deepMerge(targetValue, sourceValue);\n      } else {\n        target[key] = sourceValue;\n      }\n    } catch {}\n  }\n\n  return target;\n}\n","import * as React from 'react';\nimport getFieldValue from './getFieldValue';\nimport isString from '../utils/isString';\nimport isArray from '../utils/isArray';\nimport { deepMerge } from '../utils/deepMerge';\nimport isUndefined from '../utils/isUndefined';\nimport { InternalFieldName, FieldValues, FieldRefs } from '../types';\nimport transformToNestObject from './transformToNestObject';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  shallowFieldsStateRef?: React.MutableRefObject<Record<string, any>>,\n  excludeDisabled?: boolean,\n  search?:\n    | InternalFieldName<TFieldValues>\n    | InternalFieldName<TFieldValues>[]\n    | { nest: boolean },\n) => {\n  const output = {} as TFieldValues;\n\n  for (const name in fieldsRef.current) {\n    if (\n      isUndefined(search) ||\n      (isString(search)\n        ? name.startsWith(search)\n        : isArray(search) && search.find((data) => name.startsWith(data)))\n    ) {\n      output[name as InternalFieldName<TFieldValues>] = getFieldValue(\n        fieldsRef,\n        name,\n        undefined,\n        excludeDisabled,\n      );\n    }\n  }\n\n  return deepMerge(\n    { ...((shallowFieldsStateRef || {}).current || {}) },\n    transformToNestObject(output),\n  );\n};\n","import isObject from './isObject';\nimport { FieldError } from '../types';\n\nexport default (error: FieldError, currentError?: FieldError): boolean =>\n  isObject(error) &&\n  isObject(currentError) &&\n  error.type === currentError.type &&\n  error.message === currentError.message &&\n  Object.keys(error.types || {}).length ===\n    Object.keys(currentError.types || {}).length &&\n  Object.entries(error.types || {}).every(\n    ([key, value]) => (currentError.types || {})[key] === value,\n  );\n","import isSameError from '../utils/isSameError';\nimport get from '../utils/get';\nimport isUndefined from '../utils/isUndefined';\nimport {\n  FieldValues,\n  InternalFieldName,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n  FieldError,\n} from '../types';\n\nexport default function shouldRenderBasedOnError<\n  TFieldValues extends FieldValues\n>({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation,\n}: {\n  errors: FieldErrors<TFieldValues>;\n  error: FieldError | undefined;\n  name: InternalFieldName<TFieldValues>;\n  validFields: FieldNamesMarkedBoolean<TFieldValues>;\n  fieldsWithValidation: FieldNamesMarkedBoolean<TFieldValues>;\n}): boolean {\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n\n  return (\n    (isValid && !!previousError) ||\n    (!isValid && !isSameError(previousError, error)) ||\n    (isValid && get(fieldsWithValidation, name) && !get(validFields, name))\n  );\n}\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\nimport { ValidationRule, ValidationValueMessage } from '../types';\n\nconst isValueMessage = (\n  value?: ValidationRule,\n): value is ValidationValueMessage => isObject(value) && !isRegex(value);\n\nexport default (validationData?: ValidationRule) =>\n  isValueMessage(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","import { isValidElement } from 'react';\nimport isString from '../utils/isString';\nimport isObject from '../utils/isObject';\nimport { Message } from '../types';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || (isObject(value) && isValidElement(value));\n","import isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport { FieldError, ValidateResult, Ref } from '../types';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import {\n  InternalFieldName,\n  ValidateResult,\n  InternalFieldErrors,\n} from '../types';\n\nexport default <TFieldValues>(\n  name: InternalFieldName<TFieldValues>,\n  validateAllFieldCriteria: boolean,\n  errors: InternalFieldErrors<TFieldValues>,\n  type: string,\n  message: ValidateResult,\n) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n\n    return {\n      ...error,\n      types: {\n        ...(error && error.types ? error.types : {}),\n        [type]: message || true,\n      },\n    };\n  }\n\n  return {};\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getCheckboxValue from './getCheckboxValue';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isRadioInput from '../utils/isRadioInput';\nimport getValueAndMessage from './getValueAndMessage';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isString from '../utils/isString';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isObject from '../utils/isObject';\nimport isFunction from '../utils/isFunction';\nimport getFieldsValue from './getFieldValue';\nimport isRegex from '../utils/isRegex';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport getValidateError from './getValidateError';\nimport appendErrors from './appendErrors';\nimport { INPUT_VALIDATION_RULES } from '../constants';\nimport {\n  Field,\n  FieldValues,\n  FieldRefs,\n  Message,\n  FieldError,\n  InternalFieldName,\n  InternalFieldErrors,\n} from '../types';\n\nexport default async <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  validateAllFieldCriteria: boolean,\n  {\n    ref,\n    ref: { type, value },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate,\n  }: Field,\n  shallowFieldsStateRef: React.MutableRefObject<Record<string, any>>,\n): Promise<InternalFieldErrors<TFieldValues>> => {\n  const fields = fieldsRef.current;\n  const name: InternalFieldName<TFieldValues> = ref.name;\n  const error: InternalFieldErrors<TFieldValues> = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...(exceedMax\n        ? appendErrorsCurry(maxType, message)\n        : appendErrorsCurry(minType, message)),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\n      (isBoolean(value) && !value) ||\n      (isCheckBox && !getCheckboxValue(options).isValid) ||\n      (isRadio && !getRadioValue(options).isValid))\n  ) {\n    const { value: requiredValue, message: requiredMessage } = isMessage(\n      required,\n    )\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (requiredValue) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message: requiredMessage,\n        ref: isRadioOrCheckbox\n          ? (((fields[name] as Field).options || [])[0] || {}).ref\n          : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\n    const { value: minValue, message: minMessage } = getValueAndMessage(min);\n\n    if (type === 'number' || (!type && !isNaN(value))) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(value);\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(value);\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxMessage,\n        minMessage,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage,\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage,\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax =\n      !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n    const exceedMin =\n      !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (pattern && !isEmpty) {\n    const { value: patternValue, message: patternMessage } = getValueAndMessage(\n      pattern,\n    );\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldsValue(fieldsRef, name, shallowFieldsStateRef);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","import isPrimitive from './isPrimitive';\nimport isObject from './isObject';\n\nexport const getPath = <T extends string, U extends object | unknown[]>(\n  path: T,\n  values: U,\n): string[] => {\n  const getInnerPath = <K>(key: K, value: U, isObject?: boolean) => {\n    const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return Object.entries(values)\n    .map(([key, value]) => getInnerPath(key, value, isObject(values)))\n    .flat(Infinity) as string[];\n};\n","import get from '../utils/get';\nimport { getPath } from '../utils/getPath';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isArray from '../utils/isArray';\nimport {\n  DeepPartial,\n  FieldValue,\n  FieldValues,\n  InternalFieldName,\n  UnpackNestedValue,\n} from '../types';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldValues: TFieldValues,\n  fieldName: InternalFieldName<TFieldValues>,\n  watchFields: Set<InternalFieldName<TFieldValues>>,\n  inputValue: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  isSingleField?: boolean,\n):\n  | FieldValue<TFieldValues>\n  | UnpackNestedValue<DeepPartial<TFieldValues>>\n  | undefined => {\n  let value;\n\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || isArray(value)) {\n      getPath(fieldName, value).forEach((name) => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value)\n    ? isSingleField\n      ? inputValue\n      : get(inputValue, fieldName)\n    : value;\n};\n","export default ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll,\n}: {\n  isOnAll?: boolean;\n  isOnBlur?: boolean;\n  isOnChange?: boolean;\n  isReValidateOnBlur?: boolean;\n  isReValidateOnChange?: boolean;\n  isBlurEvent?: boolean;\n  isSubmitted?: boolean;\n  isOnTouch?: boolean;\n  isTouched?: boolean;\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n","export default (name: string) => name.substring(0, name.indexOf('['));\n","import isObject from '../utils/isObject';\nimport isArray from '../utils/isArray';\n\nexport default function deepEqual(object1: any = [], object2: any = []) {\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (const key of keys1) {\n    const val1 = object1[key];\n    const val2 = object2[key];\n\n    if (\n      (isObject(val1) || isArray(val1)) && (isObject(val2) || isArray(val2))\n        ? !deepEqual(val1, val2)\n        : val1 !== val2\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { FieldValues, InternalFieldName } from '../types';\n\nexport const isMatchFieldArrayName = (name: string, searchName: string) =>\n  RegExp(\n    `^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]'),\n  ).test(name);\n\nexport default (\n  names: Set<InternalFieldName<FieldValues>>,\n  name: InternalFieldName<FieldValues>,\n) => [...names].some((current) => isMatchFieldArrayName(name, current));\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-one`;\n","import * as React from 'react';\nimport { Field, FieldRefs } from '../types';\nimport isDetached from './isDetached';\n\nexport default function onDomRemove<TFieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  removeFieldEventListenerAndRef: (\n    field: Field | undefined,\n    forceDelete?: boolean,\n  ) => void,\n): MutationObserver {\n  const observer = new MutationObserver((): void => {\n    for (const field of Object.values(fieldsRef.current)) {\n      if (field && field.options) {\n        for (const option of field.options) {\n          if (option && option.ref && isDetached(option.ref)) {\n            removeFieldEventListenerAndRef(field);\n          }\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true,\n  });\n\n  return observer;\n}\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n","import isRadioInput from './isRadioInput';\nimport isCheckBoxInput from './isCheckBoxInput';\nimport { FieldElement } from '../types';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","import * as React from 'react';\nimport attachEventListeners from './logic/attachEventListeners';\nimport transformToNestObject from './logic/transformToNestObject';\nimport focusOnErrorField from './logic/focusOnErrorField';\nimport findRemovedFieldAndRemoveListener from './logic/findRemovedFieldAndRemoveListener';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport shouldRenderBasedOnError from './logic/shouldRenderBasedOnError';\nimport validateField from './logic/validateField';\nimport assignWatchFields from './logic/assignWatchFields';\nimport skipValidation from './logic/skipValidation';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport deepEqual from './utils/deepEqual';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isRadioInput from './utils/isRadioInput';\nimport isSelectInput from './utils/isSelectInput';\nimport isFileInput from './utils/isFileInput';\nimport onDomRemove from './utils/onDomRemove';\nimport isObject from './utils/isObject';\nimport { getPath } from './utils/getPath';\nimport isPrimitive from './utils/isPrimitive';\nimport isFunction from './utils/isFunction';\nimport isArray from './utils/isArray';\nimport isString from './utils/isString';\nimport isSameError from './utils/isSameError';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport unset from './utils/unset';\nimport modeChecker from './utils/validationModeChecker';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport filterOutFalsy from './utils/filterOutFalsy';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isHTMLElement from './utils/isHTMLElement';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  UseFormMethods,\n  FieldValues,\n  UnpackNestedValue,\n  FieldName,\n  InternalFieldName,\n  FieldValue,\n  FieldErrors,\n  Field,\n  FieldRefs,\n  UseFormOptions,\n  ValidationRules,\n  SubmitHandler,\n  FieldElement,\n  FormStateProxy,\n  ReadFormState,\n  Ref,\n  HandleChange,\n  RadioOrCheckboxOption,\n  OmitResetState,\n  DefaultValuesAtRender,\n  NestedValue,\n  SetValueConfig,\n  ErrorOption,\n  FormState,\n  SubmitErrorHandler,\n  FieldNamesMarkedBoolean,\n  LiteralToPrimitive,\n  DeepPartial,\n  NonUndefined,\n  InternalNameSet,\n  DefaultValues,\n  FieldError,\n} from './types';\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isWeb =\n  typeof document !== UNDEFINED &&\n  !isWindowUndefined &&\n  !isUndefined(window.HTMLElement);\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {},\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode,\n}: UseFormOptions<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs<TFieldValues>>({});\n  const fieldArrayDefaultValuesRef = React.useRef<\n    Record<InternalFieldName<FieldValues>, unknown[]>\n  >({});\n  const watchFieldsRef = React.useRef<InternalNameSet<TFieldValues>>(new Set());\n  const useWatchFieldsRef = React.useRef<\n    Record<string, Set<InternalFieldName<TFieldValues>>>\n  >({});\n  const useWatchRenderFunctionsRef = React.useRef<\n    Record<InternalFieldName<FieldValues>, () => void>\n  >({});\n  const fieldsWithValidationRef = React.useRef<\n    FieldNamesMarkedBoolean<TFieldValues>\n  >({});\n  const validFieldsRef = React.useRef<FieldNamesMarkedBoolean<TFieldValues>>(\n    {},\n  );\n  const defaultValuesRef = React.useRef<DefaultValues<TFieldValues>>(\n    defaultValues,\n  );\n  const defaultValuesAtRenderRef = React.useRef(\n    {} as DefaultValuesAtRender<TFieldValues>,\n  );\n  const isUnMount = React.useRef(false);\n  const isWatchAllRef = React.useRef(false);\n  const handleChangeRef = React.useRef<HandleChange>();\n  const shallowFieldsStateRef = React.useRef(\n    shouldUnregister ? {} : defaultValues,\n  );\n  const resetFieldArrayFunctionRef = React.useRef<\n    Record<\n      InternalFieldName<FieldValues>,\n      (data?: UnpackNestedValue<DeepPartial<TFieldValues>>) => void\n    >\n  >({});\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<InternalNameSet<TFieldValues>>(\n    new Set(),\n  );\n  const modeRef = React.useRef(modeChecker(mode));\n  const { isOnSubmit, isOnTouch } = modeRef.current;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = React.useState<FormState<TFieldValues>>({\n    isDirty: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {},\n  });\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n  });\n  const formStateRef = React.useRef(formState);\n  const observerRef = React.useRef<MutationObserver | undefined>();\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnChange: isReValidateOnChange,\n  } = React.useRef(modeChecker(reValidateMode)).current;\n\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n\n  const updateFormState = React.useCallback(\n    (state: Partial<FormState<TFieldValues>> = {}) =>\n      !isUnMount.current &&\n      setFormState({\n        ...formStateRef.current,\n        ...state,\n      }),\n    [],\n  );\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      error: FieldError | undefined,\n      shouldRender: boolean | null = false,\n      state: {\n        dirtyFields?: FieldNamesMarkedBoolean<TFieldValues>;\n        isDirty?: boolean;\n        touched?: FieldNamesMarkedBoolean<TFieldValues>;\n      } = {},\n      isValid?: boolean,\n    ): boolean | void => {\n      let shouldReRender =\n        shouldRender ||\n        shouldRenderBasedOnError<TFieldValues>({\n          errors: formStateRef.current.errors,\n          error,\n          name,\n          validFields: validFieldsRef.current,\n          fieldsWithValidation: fieldsWithValidationRef.current,\n        });\n      const previousError = get(formStateRef.current.errors, name);\n\n      if (error) {\n        unset(validFieldsRef.current, name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !isSameError(previousError, error);\n        set(formStateRef.current.errors, name, error);\n      } else {\n        if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n          set(validFieldsRef.current, name, true);\n          shouldReRender = shouldReRender || previousError;\n        }\n        unset(formStateRef.current.errors, name);\n      }\n\n      if (\n        (shouldReRender && !isNullOrUndefined(shouldRender)) ||\n        !isEmptyObject(state)\n      ) {\n        updateFormState({\n          ...state,\n          errors: formStateRef.current.errors,\n          ...(resolverRef.current ? { isValid: !!isValid } : {}),\n        });\n      }\n    },\n    [],\n  );\n\n  const setFieldValue = React.useCallback(\n    (\n      { ref, options }: Field,\n      rawValue:\n        | FieldValue<TFieldValues>\n        | UnpackNestedValue<DeepPartial<TFieldValues>>\n        | string[]\n        | undefined\n        | null\n        | boolean,\n    ) => {\n      const value =\n        isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\n          ? ''\n          : rawValue;\n\n      if (isRadioInput(ref) && options) {\n        options.forEach(\n          ({ ref: radioRef }: { ref: HTMLInputElement }) =>\n            (radioRef.checked = radioRef.value === value),\n        );\n      } else if (isFileInput(ref) && !isString(value)) {\n        ref.files = value as FileList;\n      } else if (isMultipleSelect(ref)) {\n        [...ref.options].forEach(\n          (selectRef) =>\n            (selectRef.selected = (value as string[]).includes(\n              selectRef.value,\n            )),\n        );\n      } else if (isCheckBoxInput(ref) && options) {\n        options.length > 1\n          ? options.forEach(\n              ({ ref: checkboxRef }) =>\n                (checkboxRef.checked = isArray(value)\n                  ? !!(value as []).find(\n                      (data: string) => data === checkboxRef.value,\n                    )\n                  : value === checkboxRef.value),\n            )\n          : (options[0].ref.checked = !!value);\n      } else {\n        ref.value = value;\n      }\n    },\n    [],\n  );\n\n  const updateAndGetDirtyState = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      shouldRender = true,\n    ): {\n      dirtyFields?: FieldNamesMarkedBoolean<TFieldValues>;\n      isDirty?: boolean;\n      touched?: FieldNamesMarkedBoolean<TFieldValues>;\n    } => {\n      if (\n        !fieldsRef.current[name] ||\n        (!readFormStateRef.current.isDirty &&\n          !readFormStateRef.current.dirtyFields)\n      ) {\n        return {};\n      }\n\n      const isFieldDirty =\n        defaultValuesAtRenderRef.current[name] !==\n        getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n      const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n      const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n      const previousIsDirty = formStateRef.current.isDirty;\n\n      isFieldDirty\n        ? set(formStateRef.current.dirtyFields, name, true)\n        : unset(formStateRef.current.dirtyFields, name);\n\n      const state = {\n        isDirty:\n          (isFieldArray &&\n            !deepEqual(\n              get(getValues(), getFieldArrayParentName(name)),\n              get(defaultValuesRef.current, getFieldArrayParentName(name)),\n            )) ||\n          !isEmptyObject(formStateRef.current.dirtyFields),\n        dirtyFields: formStateRef.current.dirtyFields,\n      };\n\n      const isChanged =\n        (readFormStateRef.current.isDirty &&\n          previousIsDirty !== state.isDirty) ||\n        (readFormStateRef.current.dirtyFields &&\n          isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\n\n      if (isChanged && shouldRender) {\n        formStateRef.current = {\n          ...formStateRef.current,\n          ...state,\n        };\n        updateFormState({\n          ...state,\n        });\n      }\n\n      return isChanged ? state : {};\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName<TFieldValues>,\n      skipReRender?: boolean | null,\n    ): Promise<boolean> => {\n      if (fieldsRef.current[name]) {\n        const error = (\n          await validateField<TFieldValues>(\n            fieldsRef,\n            isValidateAllFieldCriteria,\n            fieldsRef.current[name] as Field,\n            shallowFieldsStateRef,\n          )\n        )[name];\n\n        shouldRenderBaseOnError(name, error, skipReRender);\n\n        return isUndefined(error);\n      }\n\n      return false;\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      names:\n        | InternalFieldName<TFieldValues>\n        | InternalFieldName<TFieldValues>[],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getValues(),\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const previousFormIsValid = formStateRef.current.isValid;\n\n      if (isArray(names)) {\n        const isInputsValid = names\n          .map((name) => {\n            const error = get(errors, name);\n\n            error\n              ? set(formStateRef.current.errors, name, error)\n              : unset(formStateRef.current.errors, name);\n\n            return !error;\n          })\n          .every(Boolean);\n\n        updateFormState({\n          isValid: isEmptyObject(errors),\n          errors: formStateRef.current.errors,\n        });\n\n        return isInputsValid;\n      } else {\n        const error = get(errors, names);\n\n        shouldRenderBaseOnError(\n          names,\n          error,\n          previousFormIsValid !== isEmptyObject(errors),\n          {},\n          isEmptyObject(errors),\n        );\n\n        return !error;\n      }\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const trigger = React.useCallback(\n    async (\n      name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n    ): Promise<boolean> => {\n      const fields = name || Object.keys(fieldsRef.current);\n\n      if (resolverRef.current) {\n        return executeSchemaOrResolverValidation(fields);\n      }\n\n      if (isArray(fields)) {\n        const result = await Promise.all(\n          fields.map(async (data) => await executeValidation(data, null)),\n        );\n        updateFormState();\n        return result.every(Boolean);\n      }\n\n      return await executeValidation(fields);\n    },\n    [executeSchemaOrResolverValidation, executeValidation],\n  );\n\n  const setInternalValues = React.useCallback(\n    <T extends string, U extends object | unknown[]>(\n      name: T,\n      value: U,\n      { shouldDirty, shouldValidate }: SetValueConfig,\n    ) => {\n      getPath(name, value).forEach((fieldName) => {\n        const data = {};\n        const field = fieldsRef.current[fieldName];\n\n        if (field) {\n          set(data, name, value);\n          setFieldValue(field, get(data, fieldName));\n\n          if (shouldDirty) {\n            updateAndGetDirtyState(fieldName);\n          }\n\n          if (shouldValidate) {\n            trigger(fieldName as FieldName<TFieldValues>);\n          }\n        }\n      });\n    },\n    [trigger, setFieldValue, updateAndGetDirtyState],\n  );\n\n  const setInternalValue = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      value: FieldValue<TFieldValues> | null | undefined | boolean,\n      config: SetValueConfig,\n    ) => {\n      if (fieldsRef.current[name]) {\n        setFieldValue(fieldsRef.current[name] as Field, value);\n        config.shouldDirty && updateAndGetDirtyState(name);\n      } else if (!isPrimitive(value)) {\n        setInternalValues(name, value, config);\n\n        if (\n          isNameInFieldArray(fieldArrayNamesRef.current, name) ||\n          fieldArrayNamesRef.current.has(name)\n        ) {\n          const fieldArrayParentName = getFieldArrayParentName(name) || name;\n          fieldArrayDefaultValuesRef.current[fieldArrayParentName] = value;\n          resetFieldArrayFunctionRef.current[fieldArrayParentName]({\n            [name]: value,\n          } as UnpackNestedValue<DeepPartial<TFieldValues>>);\n        }\n      }\n\n      !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n    },\n    [updateAndGetDirtyState, setFieldValue, setInternalValues],\n  );\n\n  const isFieldWatched = (name: string) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = (name: string, found = true): boolean => {\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (const key in useWatchFieldsRef.current) {\n        if (\n          !name ||\n          useWatchFieldsRef.current[key].has(name) ||\n          useWatchFieldsRef.current[key].has(getFieldArrayParentName(name)) ||\n          !useWatchFieldsRef.current[key].size\n        ) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    value: NonUndefined<TFieldValue> extends NestedValue<infer U>\n      ? U\n      : UnpackNestedValue<DeepPartial<LiteralToPrimitive<TFieldValue>>>,\n    config: SetValueConfig = {},\n  ): void {\n    setInternalValue(name, value as TFieldValues[string], config);\n\n    if (isFieldWatched(name)) {\n      updateFormState();\n    }\n\n    renderWatchedInputs(name);\n\n    if (config.shouldValidate) {\n      trigger(name as any);\n    }\n  }\n\n  handleChangeRef.current = handleChangeRef.current\n    ? handleChangeRef.current\n    : async ({ type, target }: Event): Promise<void | boolean> => {\n        const name = (target as Ref)!.name;\n        const field = fieldsRef.current[name];\n        let error;\n        let isValid;\n\n        if (field) {\n          const isBlurEvent = type === EVENTS.BLUR;\n          const shouldSkipValidation = skipValidation({\n            isBlurEvent,\n            isReValidateOnChange,\n            isReValidateOnBlur,\n            isTouched: !!get(formStateRef.current.touched, name),\n            isSubmitted: formStateRef.current.isSubmitted,\n            ...modeRef.current,\n          });\n          let state = updateAndGetDirtyState(name, false);\n          let shouldRender = !isEmptyObject(state) || isFieldWatched(name);\n\n          if (\n            isBlurEvent &&\n            !get(formStateRef.current.touched, name) &&\n            readFormStateRef.current.touched\n          ) {\n            set(formStateRef.current.touched, name, true);\n            state = {\n              ...state,\n              touched: formStateRef.current.touched,\n            };\n          }\n\n          if (shouldSkipValidation) {\n            renderWatchedInputs(name);\n            return (\n              (!isEmptyObject(state) ||\n                (shouldRender && isEmptyObject(state))) &&\n              updateFormState(state)\n            );\n          }\n\n          if (resolverRef.current) {\n            const { errors } = await resolverRef.current(\n              getValues(),\n              contextRef.current,\n              isValidateAllFieldCriteria,\n            );\n            const previousFormIsValid = formStateRef.current.isValid;\n\n            error = get(errors, name);\n\n            isValid = isEmptyObject(errors);\n\n            if (previousFormIsValid !== isValid) {\n              shouldRender = true;\n            }\n          } else {\n            error = (\n              await validateField<TFieldValues>(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              )\n            )[name];\n          }\n\n          renderWatchedInputs(name);\n          shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n        }\n      };\n\n  function getValues(): UnpackNestedValue<TFieldValues>;\n  function getValues<TFieldName extends string, TFieldValue extends unknown>(\n    name: TFieldName,\n  ): TFieldName extends keyof TFieldValues\n    ? UnpackNestedValue<TFieldValues>[TFieldName]\n    : TFieldValue;\n  function getValues<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function getValues(payload?: string | string[]): unknown {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (isArray(payload)) {\n      const data = {};\n\n      for (const name of payload) {\n        set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      }\n\n      return data;\n    }\n\n    return getFieldsValues(fieldsRef, shallowFieldsStateRef);\n  }\n\n  const validateResolver = React.useCallback(\n    async (values = {}) => {\n      const { errors } = await resolverRef.current!(\n        {\n          ...defaultValuesRef.current,\n          ...getValues(),\n          ...values,\n        },\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const previousFormIsValid = formStateRef.current.isValid;\n      const isValid = isEmptyObject(errors);\n\n      if (previousFormIsValid !== isValid) {\n        updateFormState({\n          isValid,\n        });\n      }\n    },\n    [isValidateAllFieldCriteria],\n  );\n\n  const removeFieldEventListener = React.useCallback(\n    (field: Field, forceDelete?: boolean) =>\n      findRemovedFieldAndRemoveListener(\n        fieldsRef,\n        handleChangeRef.current!,\n        field,\n        shallowFieldsStateRef,\n        shouldUnregister,\n        forceDelete,\n      ),\n    [shouldUnregister],\n  );\n\n  const removeFieldEventListenerAndRef = React.useCallback(\n    (field: Field | undefined, forceDelete?: boolean) => {\n      if (field) {\n        removeFieldEventListener(field, forceDelete);\n\n        if (shouldUnregister && !filterOutFalsy(field.options || []).length) {\n          delete defaultValuesAtRenderRef.current[field.ref.name];\n          unset(validFieldsRef.current, field.ref.name);\n          unset(fieldsWithValidationRef.current, field.ref.name);\n          unset(formStateRef.current.errors, field.ref.name);\n          unset(formStateRef.current.dirtyFields, field.ref.name);\n          unset(formStateRef.current.touched, field.ref.name);\n\n          updateFormState({\n            errors: formStateRef.current.errors,\n            isDirty: !isEmptyObject(formStateRef.current.dirtyFields),\n            dirtyFields: formStateRef.current.dirtyFields,\n            touched: formStateRef.current.touched,\n          });\n\n          resolverRef.current && validateResolver();\n        }\n      }\n    },\n    [validateResolver, removeFieldEventListener],\n  );\n\n  function clearErrors(\n    name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    name &&\n      (isArray(name) ? name : [name]).forEach((inputName) =>\n        fieldsRef.current[inputName]\n          ? delete formStateRef.current.errors[inputName]\n          : unset(formStateRef.current.errors, inputName),\n      );\n\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {},\n    });\n  }\n\n  function setError(\n    name: FieldName<TFieldValues>,\n    error: ErrorOption = {},\n  ): void {\n    const ref = (fieldsRef.current[name] || {})!.ref;\n\n    set(formStateRef.current.errors, name, {\n      ...error,\n      ref,\n    });\n\n    updateFormState({\n      isValid: false,\n      errors: formStateRef.current.errors,\n    });\n\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  const watchInternal = React.useCallback(\n    (\n      fieldNames?: string | string[],\n      defaultValue?: unknown,\n      watchId?: string,\n    ) => {\n      const watchFields = watchId\n        ? useWatchFieldsRef.current[watchId]\n        : watchFieldsRef.current;\n      const combinedDefaultValues = isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : defaultValue;\n      const fieldValues = getFieldsValues<TFieldValues>(\n        fieldsRef,\n        shallowFieldsStateRef,\n        false,\n        fieldNames,\n      );\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (fieldNames) {\n          const fieldRefNames = Object.keys(fieldsRef.current);\n\n          if (fieldRefNames.length) {\n            (isArray(fieldNames) ? fieldNames : [fieldNames]).forEach(\n              (name) => {\n                if (\n                  !fieldRefNames.find((fieldName) => fieldName.startsWith(name))\n                ) {\n                  console.warn(\n                    ` watched fields: ${fieldNames} are not found.`,\n                  );\n                }\n              },\n            );\n          }\n        }\n      }\n\n      if (isString(fieldNames)) {\n        return assignWatchFields<TFieldValues>(\n          fieldValues,\n          fieldNames,\n          watchFields,\n          isUndefined(defaultValue)\n            ? get(combinedDefaultValues, fieldNames)\n            : (defaultValue as UnpackNestedValue<DeepPartial<TFieldValues>>),\n          true,\n        );\n      }\n\n      if (isArray(fieldNames)) {\n        return fieldNames.reduce(\n          (previous, name) => ({\n            ...previous,\n            [name]: assignWatchFields<TFieldValues>(\n              fieldValues,\n              name,\n              watchFields,\n              combinedDefaultValues as UnpackNestedValue<\n                DeepPartial<TFieldValues>\n              >,\n            ),\n          }),\n          {},\n        );\n      }\n\n      if (isUndefined(watchId)) {\n        isWatchAllRef.current = true;\n      }\n\n      return transformToNestObject(\n        (!isEmptyObject(fieldValues) && fieldValues) ||\n          (combinedDefaultValues as FieldValues),\n      );\n    },\n    [],\n  );\n\n  function watch(): UnpackNestedValue<TFieldValues>;\n  function watch<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    defaultValue?: UnpackNestedValue<LiteralToPrimitive<TFieldValue>>,\n  ): UnpackNestedValue<LiteralToPrimitive<TFieldValue>>;\n  function watch<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n    defaultValues?: UnpackNestedValue<\n      DeepPartial<Pick<TFieldValues, TFieldName>>\n    >,\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function watch(\n    names: string[],\n    defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ): UnpackNestedValue<DeepPartial<TFieldValues>>;\n  function watch(\n    fieldNames?: string | string[],\n    defaultValue?: unknown,\n  ): unknown {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(\n    name: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    (isArray(name) ? name : [name]).forEach((fieldName) =>\n      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true),\n    );\n  }\n\n  function registerFieldRef<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: TFieldElement & Ref,\n    validateOptions: ValidationRules | null = {},\n  ): ((name: InternalFieldName<TFieldValues>) => void) | void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn(\n          ' Field is missing `name` attribute',\n          ref,\n          `https://react-hook-form.com/api#useForm`,\n        );\n      }\n\n      if (\n        fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\n        !RegExp(\n          `^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`\n            .replace(/\\[/g, '\\\\[')\n            .replace(/\\]/g, '\\\\]'),\n        ).test(ref.name)\n      ) {\n        return console.warn(\n          ' `name` prop should be in object shape: name=\"test[index].name\"',\n          ref,\n          'https://react-hook-form.com/api#useFieldArray',\n        );\n      }\n    }\n\n    const { name, type, value } = ref;\n    const fieldRefAndValidationOptions = {\n      ref,\n      ...validateOptions,\n    };\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    const compareRef = (currentRef: Ref) =>\n      isWeb && (!isHTMLElement(ref) || currentRef === ref);\n    let field = fields[name] as Field;\n    let isEmptyDefaultValue = true;\n    let isFieldArray;\n    let defaultValue;\n\n    if (\n      field &&\n      (isRadioOrCheckbox\n        ? isArray(field.options) &&\n          filterOutFalsy(field.options).find((option) => {\n            return value === option.ref.value && compareRef(option.ref);\n          })\n        : compareRef(field.ref))\n    ) {\n      fields[name] = {\n        ...field,\n        ...validateOptions,\n      };\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox\n        ? {\n            options: [\n              ...filterOutFalsy((field && field.options) || []),\n              {\n                ref,\n              } as RadioOrCheckboxOption,\n            ],\n            ref: { type, name },\n            ...validateOptions,\n          }\n        : {\n            ...fieldRefAndValidationOptions,\n          };\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n\n    const isEmptyUnmountFields = isUndefined(\n      get(shallowFieldsStateRef.current, name),\n    );\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(\n        isEmptyUnmountFields\n          ? defaultValuesRef.current\n          : shallowFieldsStateRef.current,\n        name,\n      );\n      isEmptyDefaultValue = isUndefined(defaultValue);\n      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(field, defaultValue);\n      }\n    }\n\n    if (resolver && !isFieldArray && readFormStateRef.current.isValid) {\n      validateResolver();\n    } else if (!isEmptyObject(validateOptions)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(\n          fieldsRef,\n          isValidateAllFieldCriteria,\n          field,\n          shallowFieldsStateRef,\n        ).then((error: FieldErrors) => {\n          const previousFormIsValid = formStateRef.current.isValid;\n\n          isEmptyObject(error)\n            ? set(validFieldsRef.current, name, true)\n            : unset(validFieldsRef.current, name);\n\n          if (previousFormIsValid !== isEmptyObject(error)) {\n            updateFormState();\n          }\n        });\n      }\n    }\n\n    if (\n      !defaultValuesAtRenderRef.current[name] &&\n      !(isFieldArray && isEmptyDefaultValue)\n    ) {\n      const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n      defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue\n        ? isObject(fieldValue)\n          ? { ...fieldValue }\n          : fieldValue\n        : defaultValue;\n    }\n\n    if (type) {\n      attachEventListeners(\n        isRadioOrCheckbox && field.options\n          ? field.options[field.options.length - 1]\n          : field,\n        isRadioOrCheckbox || isSelectInput(ref),\n        handleChangeRef.current,\n      );\n    }\n  }\n\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    rules?: ValidationRules,\n  ): (ref: (TFieldElement & Ref) | null) => void;\n  function register(\n    name: FieldName<TFieldValues>,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: (TFieldElement & Ref) | null,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    refOrValidationOptions?:\n      | FieldName<TFieldValues>\n      | ValidationRules\n      | (TFieldElement & Ref)\n      | null,\n    rules?: ValidationRules,\n  ): ((ref: (TFieldElement & Ref) | null) => void) | void {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldRef({ name: refOrValidationOptions }, rules);\n      } else if (\n        isObject(refOrValidationOptions) &&\n        'name' in refOrValidationOptions\n      ) {\n        registerFieldRef(refOrValidationOptions, rules);\n      } else {\n        return (ref: (TFieldElement & Ref) | null) =>\n          ref && registerFieldRef(ref, refOrValidationOptions);\n      }\n    }\n  }\n\n  const handleSubmit = React.useCallback(\n    <TSubmitFieldValues extends FieldValues = TFieldValues>(\n      onValid: SubmitHandler<TSubmitFieldValues>,\n      onInvalid?: SubmitErrorHandler<TFieldValues>,\n    ) => async (e?: React.BaseSyntheticEvent): Promise<void> => {\n      if (e && e.preventDefault) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldErrors: FieldErrors<TFieldValues> = {};\n      let fieldValues = getFieldsValues(fieldsRef, shallowFieldsStateRef, true);\n\n      if (readFormStateRef.current.isSubmitting) {\n        updateFormState({\n          isSubmitting: true,\n        });\n      }\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            fieldValues,\n            contextRef.current,\n            isValidateAllFieldCriteria,\n          );\n          formStateRef.current.errors = errors;\n          fieldErrors = errors;\n          fieldValues = values;\n        } else {\n          for (const field of Object.values(fieldsRef.current)) {\n            if (field) {\n              const {\n                ref: { name },\n              } = field;\n\n              const fieldError = await validateField(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              );\n\n              if (fieldError[name]) {\n                set(fieldErrors, name, fieldError[name]);\n                unset(validFieldsRef.current, name);\n              } else if (get(fieldsWithValidationRef.current, name)) {\n                unset(formStateRef.current.errors, name);\n                set(validFieldsRef.current, name, true);\n              }\n            }\n          }\n        }\n\n        if (\n          isEmptyObject(fieldErrors) &&\n          Object.keys(formStateRef.current.errors).every(\n            (name) => name in fieldsRef.current,\n          )\n        ) {\n          updateFormState({\n            errors: {},\n            isSubmitting: true,\n          });\n          await onValid(\n            fieldValues as UnpackNestedValue<TSubmitFieldValues>,\n            e,\n          );\n        } else {\n          formStateRef.current.errors = {\n            ...formStateRef.current.errors,\n            ...fieldErrors,\n          };\n          if (onInvalid) {\n            await onInvalid(fieldErrors, e);\n          }\n          if (shouldFocusError) {\n            focusOnErrorField(fieldsRef.current, fieldErrors);\n          }\n        }\n      } finally {\n        updateFormState({\n          isSubmitted: true,\n          isSubmitting: false,\n          isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n          errors: formStateRef.current.errors,\n          submitCount: formStateRef.current.submitCount + 1,\n        });\n      }\n    },\n    [shouldFocusError, isValidateAllFieldCriteria],\n  );\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields,\n  }: OmitResetState) => {\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    defaultValuesAtRenderRef.current = {} as DefaultValuesAtRender<\n      TFieldValues\n    >;\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n\n    updateFormState({\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isSubmitting: false,\n      isSubmitSuccessful: false,\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isValid: isValid ? formStateRef.current.isValid : true,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {},\n    });\n  };\n\n  const reset = (\n    values?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n    omitResetState: OmitResetState = {},\n  ): void => {\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const { ref, options } = field;\n          const inputRef =\n            isRadioOrCheckboxFunction(ref) && isArray(options)\n              ? options[0].ref\n              : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n\n    defaultValuesRef.current = values || { ...defaultValuesRef.current };\n\n    if (values) {\n      renderWatchedInputs('');\n    }\n\n    shallowFieldsStateRef.current = shouldUnregister ? {} : values || {};\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(\n      (resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray(),\n    );\n\n    resetRefs(omitResetState);\n  };\n\n  observerRef.current =\n    observerRef.current || !isWeb\n      ? observerRef.current\n      : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n\n  React.useEffect(() => {\n    isUnMount.current = false;\n\n    return () => {\n      isUnMount.current = true;\n\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      fieldsRef.current &&\n        Object.values(fieldsRef.current).forEach((field) =>\n          removeFieldEventListenerAndRef(field, true),\n        );\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid =\n      deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\n      isEmptyObject(formStateRef.current.errors);\n  }\n\n  const commonProps = {\n    trigger,\n    setValue: React.useCallback(setValue, [setInternalValue, trigger]),\n    getValues: React.useCallback(getValues, []),\n    register: React.useCallback(register, [defaultValuesRef.current]),\n    unregister: React.useCallback(unregister, []),\n  };\n\n  const control = {\n    removeFieldEventListener,\n    renderWatchedInputs,\n    watchInternal,\n    mode: modeRef.current,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange,\n    },\n    fieldsRef,\n    isWatchAllRef,\n    watchFieldsRef,\n    resetFieldArrayFunctionRef,\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    fieldArrayDefaultValuesRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    readFormStateRef,\n    formStateRef,\n    defaultValuesRef,\n    shallowFieldsStateRef,\n    updateFormState,\n    shouldUnregister,\n    validateResolver: resolver ? validateResolver : undefined,\n    ...commonProps,\n  };\n\n  return {\n    watch,\n    control,\n    formState: isProxyEnabled\n      ? new Proxy(formState, {\n          get: (obj, prop: keyof FormStateProxy) => {\n            if (\n              process.env.NODE_ENV !== 'production' &&\n              prop === 'isValid' &&\n              isOnSubmit\n            ) {\n              console.warn(\n                ' `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState',\n              );\n            }\n\n            if (prop in obj) {\n              readFormStateRef.current[prop] = true;\n              return obj[prop];\n            }\n\n            return undefined;\n          },\n        })\n      : formState,\n    handleSubmit,\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    setError: React.useCallback(setError, []),\n    errors: formState.errors,\n    ...commonProps,\n  };\n}\n","import * as React from 'react';\nimport { UseFormMethods, FieldValues, FormProviderProps } from './types';\n\nconst FormContext = React.createContext<UseFormMethods | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormMethods<TFieldValues> =>\n  React.useContext(FormContext) as UseFormMethods<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>({\n  children,\n  ...props\n}: FormProviderProps<TFieldValues>) => (\n  <FormContext.Provider value={{ ...props } as UseFormMethods}>\n    {children}\n  </FormContext.Provider>\n);\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import isUndefined from './isUndefined';\nimport isArray from './isArray';\nimport filterOutFalsy from './filterOutFalsy';\n\nconst removeAt = <T>(data: T[], index: number): T[] => [\n  ...data.slice(0, index),\n  ...data.slice(index + 1),\n];\n\nfunction removeAtIndexes<T>(data: T[], index: number[]): T[] {\n  let k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return filterOutFalsy(data);\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : isArray(index)\n    ? removeAtIndexes(data, index)\n    : removeAt(data, index);\n","import isUndefined from './isUndefined';\nimport isArray from './isArray';\n\nexport default <T>(\n  data: (T | undefined)[],\n  from: number,\n  to: number,\n): (T | undefined)[] => {\n  if (isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n","import isArray from './isArray';\n\nexport default function prepend<T>(data: T[]): (T | undefined)[];\nexport default function prepend<T>(data: T[], value: T | T[]): T[];\nexport default function prepend<T>(\n  data: T[],\n  value?: T | T[],\n): (T | undefined)[] {\n  return [...(isArray(value) ? value : [value || undefined]), ...data];\n}\n","import isArray from './isArray';\n\nexport default function insert<T>(data: T[], index: number): (T | undefined)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | undefined)[] {\n  return [\n    ...data.slice(0, index),\n    ...(isArray(value) ? value : [value || undefined]),\n    ...data.slice(index),\n  ];\n}\n","import isArray from './isArray';\n\nexport default <T>(value: T | T[]): undefined[] | undefined =>\n  isArray(value) ? Array(value.length).fill(undefined) : undefined;\n","import isArray from './isArray';\nimport isObject from './isObject';\n\nfunction mapValueToBoolean<U>(value: U): boolean[] | Record<string, boolean>[] {\n  if (isObject(value)) {\n    const object: Record<string, boolean> = {};\n\n    for (const key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nexport default <T>(value: T) =>\n  ((isArray(value) ? value : [value]) as T[]).map(mapValueToBoolean).flat();\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport { isMatchFieldArrayName } from './logic/isNameInFieldArray';\nimport generateId from './logic/generateId';\nimport deepEqual from './utils/deepEqual';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport get from './utils/get';\nimport set from './utils/set';\nimport isUndefined from './utils/isUndefined';\nimport removeArrayAt from './utils/remove';\nimport unset from './utils/unset';\nimport moveArrayAt from './utils/move';\nimport swapArrayAt from './utils/swap';\nimport prependAt from './utils/prepend';\nimport isArray from './utils/isArray';\nimport insertAt from './utils/insert';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport filterBooleanArray from './utils/filterBooleanArray';\nimport filterOutFalsy from './utils/filterOutFalsy';\nimport {\n  Field,\n  FieldValues,\n  UseFieldArrayOptions,\n  Control,\n  ArrayField,\n  UnpackNestedValue,\n  DeepPartial,\n} from './types';\n\nconst appendId = <TValue extends object, TKeyName extends string>(\n  value: TValue,\n  keyName: TKeyName,\n): Partial<ArrayField<TValue, TKeyName>> => ({\n  [keyName]: generateId(),\n  ...value,\n});\n\nconst mapIds = <TData extends object, TKeyName extends string>(\n  data: TData | TData[],\n  keyName: TKeyName,\n) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\n\nexport const useFieldArray = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id',\n  TControl extends Control = Control\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayOptions<TKeyName, TControl>) => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        ' useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray',\n      );\n    }\n\n    if (!name) {\n      console.warn(\n        ' useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray',\n      );\n    }\n  }\n\n  const focusIndexRef = React.useRef(-1);\n  const {\n    isWatchAllRef,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    formStateRef,\n    formStateRef: {\n      current: { dirtyFields, touched },\n    },\n    shallowFieldsStateRef,\n    updateFormState,\n    readFormStateRef,\n    watchFieldsRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n    validateResolver,\n    renderWatchedInputs,\n    getValues,\n  } = control || methods.control;\n\n  const fieldArrayParentName = getFieldArrayParentName(name);\n  const getDefaultValues = () => [\n    ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\n      ? get(fieldArrayDefaultValuesRef.current, name, [])\n      : get(defaultValuesRef.current, name, [])),\n  ];\n  const memoizedDefaultValues = React.useRef<Partial<TFieldArrayValues>[]>(\n    getDefaultValues(),\n  );\n  const [fields, setFields] = React.useState<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(mapIds(memoizedDefaultValues.current, keyName));\n  const allFields = React.useRef<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(fields);\n\n  const getCurrentFieldsValues = () =>\n    get(getValues() || {}, name, allFields.current).map(\n      (item: Partial<TFieldArrayValues>, index: number) => ({\n        ...allFields.current[index],\n        ...item,\n      }),\n    );\n\n  allFields.current = fields;\n  fieldArrayNamesRef.current.add(name);\n\n  if (!get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\n    set(\n      fieldArrayDefaultValuesRef.current,\n      fieldArrayParentName,\n      get(defaultValuesRef.current, fieldArrayParentName),\n    );\n  }\n\n  const appendValueWithKey = (values: Partial<TFieldArrayValues>[]) =>\n    values.map((value: Partial<TFieldArrayValues>) => appendId(value, keyName));\n\n  const setFieldAndValidState = (\n    fieldsValues: Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n  ) => {\n    setFields(fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = {};\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const getIsDirtyState = (\n    flagOrFields?: (Partial<TFieldArrayValues> | undefined)[],\n  ): boolean =>\n    (readFormStateRef.current.isDirty ||\n      readFormStateRef.current.dirtyFields) &&\n    (isUndefined(flagOrFields) ||\n      !deepEqual(\n        flagOrFields.map(({ [keyName]: omitted, ...rest } = {}) => rest),\n        get(defaultValuesRef.current, name),\n      ));\n\n  const resetFields = () => {\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\n        removeFieldEventListener(fieldsRef.current[key] as Field, true);\n      }\n    }\n  };\n\n  const cleanup = <T>(ref: T) =>\n    !filterOutFalsy(get(ref, name, [])).length && unset(ref, name);\n\n  const batchStateUpdate = <T extends Function>(\n    method: T,\n    args: {\n      argA?: unknown;\n      argB?: unknown;\n      argC?: unknown;\n      argD?: unknown;\n    },\n    isDirty = true,\n    shouldSet = true,\n    shouldUpdateValid = false,\n  ) => {\n    if (get(shallowFieldsStateRef.current, name)) {\n      const output = method(\n        get(shallowFieldsStateRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n      cleanup(shallowFieldsStateRef.current);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      const output = method(\n        get(fieldArrayDefaultValuesRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\n      cleanup(fieldArrayDefaultValuesRef.current);\n    }\n\n    if (isArray(get(formStateRef.current.errors, name))) {\n      const output = method(\n        get(formStateRef.current.errors, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touched && get(touched, name)) {\n      const output = method(get(touched, name), args.argA, args.argB);\n      shouldSet && set(touched, name, output);\n      cleanup(touched);\n    }\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      const output = method(get(dirtyFields, name, []), args.argC, args.argD);\n      shouldSet && set(dirtyFields, name, output);\n      cleanup(dirtyFields);\n    }\n\n    if (\n      shouldUpdateValid &&\n      readFormStateRef.current.isValid &&\n      !validateResolver\n    ) {\n      set(\n        validFieldsRef.current,\n        name,\n        method(get(validFieldsRef.current, name, []), args.argA),\n      );\n      cleanup(validFieldsRef.current);\n\n      set(\n        fieldsWithValidationRef.current,\n        name,\n        method(get(fieldsWithValidationRef.current, name, []), args.argA),\n      );\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    updateFormState({\n      errors: formStateRef.current.errors,\n      dirtyFields,\n      isDirty,\n      touched,\n    });\n  };\n\n  const append = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    setFieldAndValidState([\n      ...allFields.current,\n      ...(isArray(value)\n        ? appendValueWithKey(value)\n        : [appendId(value, keyName)]),\n    ]);\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      set(dirtyFields, name, [\n        ...(isArray(get(dirtyFields, name))\n          ? get(dirtyFields, name)\n          : fillEmptyArray(allFields.current)),\n        ...filterBooleanArray(value),\n      ]);\n      updateFormState({\n        isDirty: true,\n        dirtyFields,\n      });\n    }\n\n    focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\n    renderWatchedInputs(name);\n  };\n\n  const prepend = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n\n    setFieldAndValidState(\n      prependAt(\n        getCurrentFieldsValues(),\n        isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)],\n      ),\n    );\n    resetFields();\n    batchStateUpdate(prependAt, {\n      argA: emptyArray,\n      argC: filterBooleanArray(value),\n    });\n    renderWatchedInputs(name);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = (index?: number | number[]) => {\n    const fieldValues = getCurrentFieldsValues();\n    setFieldAndValidState(removeArrayAt(fieldValues, index));\n    resetFields();\n    batchStateUpdate(\n      removeArrayAt,\n      {\n        argA: index,\n        argC: index,\n      },\n      getIsDirtyState(removeArrayAt(fieldValues, index)),\n      true,\n      true,\n    );\n\n    renderWatchedInputs(name);\n  };\n\n  const insert = (\n    index: number,\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n\n    setFieldAndValidState(\n      insertAt(\n        fieldValues,\n        index,\n        isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)],\n      ),\n    );\n    resetFields();\n    batchStateUpdate(\n      insertAt,\n      {\n        argA: index,\n        argB: emptyArray,\n        argC: index,\n        argD: filterBooleanArray(value),\n      },\n      getIsDirtyState(insertAt(fieldValues, index)),\n    );\n    renderWatchedInputs(name);\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      swapArrayAt,\n      {\n        argA: indexA,\n        argB: indexB,\n        argC: indexA,\n        argD: indexB,\n      },\n      getIsDirtyState(fieldValues),\n      false,\n    );\n    renderWatchedInputs(name);\n  };\n\n  const move = (from: number, to: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      moveArrayAt,\n      {\n        argA: from,\n        argB: to,\n        argC: from,\n        argD: to,\n      },\n      getIsDirtyState(fieldValues),\n      false,\n    );\n    renderWatchedInputs(name);\n  };\n\n  const reset = <TFieldValues>(\n    data?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ) => {\n    resetFields();\n    !data && unset(fieldArrayDefaultValuesRef.current, name);\n    unset(shallowFieldsStateRef.current, name);\n    memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\n    setFields(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  React.useEffect(() => {\n    const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      defaultValues.pop();\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues);\n    }\n\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else if (watchFieldsRef) {\n      let shouldRenderUseWatch = true;\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          updateFormState();\n          shouldRenderUseWatch = false;\n          break;\n        }\n      }\n\n      shouldRenderUseWatch && renderWatchedInputs(name);\n    }\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n        if (\n          key.startsWith(`${name}[${focusIndexRef.current}]`) &&\n          field!.ref.focus\n        ) {\n          field!.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n\n  React.useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = reset;\n    }\n\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert, [name]),\n    fields,\n  };\n};\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport isUndefined from './utils/isUndefined';\nimport isString from './utils/isString';\nimport generateId from './logic/generateId';\nimport get from './utils/get';\nimport isArray from './utils/isArray';\nimport isObject from './utils/isObject';\nimport {\n  DeepPartial,\n  UseWatchOptions,\n  FieldValues,\n  UnpackNestedValue,\n  Control,\n} from './types';\n\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  control?: Control;\n}): undefined | UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  defaultValue: UnpackNestedValue<TWatchFieldValue>;\n  control?: Control;\n}): UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  name: string[];\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValues>({\n  control,\n  name,\n  defaultValue,\n}: UseWatchOptions): TWatchFieldValues {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        ' useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch',\n      );\n    }\n\n    if (name === '') {\n      console.warn(\n        ' useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch',\n      );\n    }\n  }\n\n  const {\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    watchInternal,\n    defaultValuesRef,\n  } = control || methods.control;\n  const [value, setValue] = React.useState<unknown>(\n    isUndefined(defaultValue)\n      ? isString(name)\n        ? get(defaultValuesRef.current, name)\n        : isArray(name)\n        ? name.reduce(\n            (previous, inputName) => ({\n              ...previous,\n              [inputName]: get(defaultValuesRef.current, inputName),\n            }),\n            {},\n          )\n        : defaultValuesRef.current\n      : defaultValue,\n  );\n  const idRef = React.useRef<string>();\n  const defaultValueRef = React.useRef(defaultValue);\n\n  const updateWatchValue = React.useCallback(() => {\n    const value = watchInternal(name, defaultValueRef.current, idRef.current);\n    setValue(\n      isObject(value) ? { ...value } : isArray(value) ? [...value] : value,\n    );\n  }, [setValue, watchInternal, defaultValueRef, name, idRef]);\n\n  React.useEffect(() => {\n    const id = (idRef.current = generateId());\n    const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    const watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(name, defaultValueRef.current, id);\n\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [\n    name,\n    updateWatchValue,\n    useWatchRenderFunctionsRef,\n    useWatchFieldsRef,\n    watchInternal,\n    defaultValueRef,\n  ]);\n\n  return (isUndefined(value) ? defaultValue : value) as TWatchFieldValues;\n}\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isPrimitive from '../utils/isPrimitive';\n\nexport default (event: any) =>\n  isPrimitive(event) ||\n  !isObject(event.target) ||\n  (isObject(event.target) && !event.type)\n    ? event\n    : isUndefined(event.target.value)\n    ? event.target.checked\n    : event.target.value;\n","import * as React from 'react';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport getInputValue from './logic/getInputValue';\nimport skipValidation from './logic/skipValidation';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport { useFormContext } from './useFormContext';\nimport { VALUE } from './constants';\nimport { Control } from './types';\nimport { ControllerProps } from './types';\n\nconst Controller = <\n  TAs extends\n    | React.ReactElement\n    | React.ComponentType<any>\n    | 'input'\n    | 'select'\n    | 'textarea',\n  TControl extends Control = Control\n>({\n  name,\n  rules,\n  as,\n  render,\n  defaultValue,\n  control,\n  onFocus,\n  ...rest\n}: ControllerProps<TAs, TControl>) => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production' && !control && !methods) {\n    throw new Error(\n      ' Controller is missing `control` prop. https://react-hook-form.com/api#Controller',\n    );\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: { isReValidateOnBlur, isReValidateOnChange },\n    formStateRef: {\n      current: { isSubmitted, touched },\n    },\n    updateFormState,\n    readFormStateRef,\n    fieldsRef,\n    fieldArrayNamesRef,\n    shallowFieldsStateRef,\n  } = control || methods.control;\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n  const getInitialValue = () =>\n    !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\n      ? get(shallowFieldsStateRef.current, name)\n      : isUndefined(defaultValue)\n      ? get(defaultValuesRef.current, name)\n      : defaultValue;\n  const [value, setInputStateValue] = React.useState(getInitialValue());\n  const valueRef = React.useRef(value);\n  const onFocusRef = React.useRef(onFocus);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined(value)) {\n      console.warn(\n        ` ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`,\n      );\n    }\n\n    if ((!as && !render) || (as && render)) {\n      console.warn(\n        ` ${name} Controller should use either the 'as' or 'render' prop, not both. https://react-hook-form.com/api#Controller`,\n      );\n    }\n\n    if (!isNotFieldArray && isUndefined(defaultValue)) {\n      console.warn(\n        ' Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller',\n      );\n    }\n  }\n\n  const shouldValidate = (isBlurEvent?: boolean) =>\n    !skipValidation({\n      isBlurEvent,\n      isReValidateOnBlur,\n      isReValidateOnChange,\n      isSubmitted,\n      isTouched: !!get(touched, name),\n      ...mode,\n    });\n\n  const commonTask = ([event]: any[]) => {\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  const registerField = React.useCallback(() => {\n    if (process.env.NODE_ENV !== 'production' && !name) {\n      return console.warn(\n        ' Field is missing `name` prop. https://react-hook-form.com/api#Controller',\n      );\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = {\n        ref: fieldsRef.current[name]!.ref,\n        ...rules,\n      };\n    } else {\n      register(\n        Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\n          set(data) {\n            setInputStateValue(data);\n            valueRef.current = data;\n          },\n          get() {\n            return valueRef.current;\n          },\n        }),\n        rules,\n      );\n      if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  }, [rules, name, register]);\n\n  React.useEffect(\n    () => () => {\n      !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\n    },\n    [unregister, name, fieldArrayNamesRef],\n  );\n\n  React.useEffect(() => {\n    registerField();\n  }, [registerField]);\n\n  React.useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  const onBlur = () => {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched,\n      });\n    }\n\n    if (shouldValidate(true)) {\n      trigger(name);\n    }\n  };\n\n  const onChange = (...event: any[]) =>\n    setValue(name, commonTask(event), {\n      shouldValidate: shouldValidate(),\n      shouldDirty: true,\n    });\n\n  const props = {\n    ...rest,\n    onChange,\n    onBlur,\n    name,\n    value,\n  };\n\n  return as\n    ? React.isValidElement(as)\n      ? React.cloneElement(as, props)\n      : React.createElement(as as string, props as any)\n    : render\n    ? render({\n        onChange,\n        onBlur,\n        value,\n        name,\n      })\n    : null;\n};\n\nexport { Controller };\n"]},"metadata":{},"sourceType":"module"}