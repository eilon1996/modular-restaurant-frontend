{"ast":null,"code":"import { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = value => value instanceof HTMLElement;\n\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all'\n};\nconst VALUE = 'value';\nconst SELECT = 'select';\nconst UNDEFINED = 'undefined';\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nfunction attachEventListeners({\n  ref\n}, shouldAttachChangeEvent, handleChange) {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isNullOrUndefined = value => value == null;\n\nvar isArray = value => Array.isArray(value);\n\nconst isObjectType = value => typeof value === 'object';\n\nvar isObject = value => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value) && !(value instanceof Date);\n\nvar isKey = value => !isArray(value) && (/^\\w*$/.test(value) || !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n\nvar stringToPath = input => {\n  const result = [];\n  input.replace(/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, (match, mathNumber, mathQuote, originalString) => {\n    result.push(mathQuote ? originalString.replace(/\\\\(\\\\)?/g, '$1') : mathNumber || match);\n  });\n  return result;\n};\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = data => Object.entries(data).reduce((previous, [key, value]) => {\n  if (!isKey(key)) {\n    set(previous, key, value);\n    return previous;\n  }\n\n  return Object.assign(Object.assign({}, previous), {\n    [key]: value\n  });\n}, {});\n\nvar isUndefined = val => val === undefined;\n\nvar filterOutFalsy = value => value.filter(Boolean);\n\nvar get = (obj, path, defaultValue) => {\n  const result = filterOutFalsy(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          field.ref.focus();\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nconst defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nvar getRadioValue = options => isArray(options) ? options.reduce((previous, option) => option && option.ref.checked ? {\n  isValid: true,\n  value: option.ref.value\n} : previous, defaultReturn) : defaultReturn;\n\nvar getMultipleSelectValue = options => [...options].filter(({\n  selected\n}) => selected).map(({\n  value\n}) => value);\n\nvar isRadioInput = element => element.type === 'radio';\n\nvar isFileInput = element => element.type === 'file';\n\nvar isCheckBoxInput = element => element.type === 'checkbox';\n\nvar isMultipleSelect = element => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = options => {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.ref.checked).map(({\n        ref: {\n          value\n        }\n      }) => value);\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    const {\n      checked,\n      value,\n      attributes\n    } = options[0].ref;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || value === '' ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled) {\n  const field = fieldsRef.current[name];\n\n  if (field) {\n    const {\n      ref: {\n        value,\n        disabled\n      },\n      ref\n    } = field;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = value => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\n  const path = updatePath.slice(0, -1);\n  const length = path.length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data) || isBoolean(data)).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\n\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\n  const {\n    ref,\n    ref: {\n      name,\n      type\n    }\n  } = field;\n  const fieldRef = fieldsRef.current[name];\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n\n    if (!isUndefined(value)) {\n      set(shallowFieldsStateRef.current, name, value);\n    }\n  }\n\n  if (!type) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    const {\n      options\n    } = fieldRef;\n\n    if (isArray(options) && options.length) {\n      filterOutFalsy(options).forEach((option, index) => {\n        const {\n          ref\n        } = option;\n\n        if (ref && isDetached(ref) && isSameRef(option, ref) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n          unset(options, `[${index}]`);\n        }\n      });\n\n      if (options && !filterOutFalsy(options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldRef, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n    delete fieldsRef.current[name];\n  }\n}\n\nvar isString = value => typeof value === 'string';\n\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepMerge(target, source) {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      if (isObject(targetValue) && isObject(sourceValue) || isArray(targetValue) && isArray(sourceValue)) {\n        target[key] = deepMerge(targetValue, sourceValue);\n      } else {\n        target[key] = sourceValue;\n      }\n    } catch (_a) {}\n  }\n\n  return target;\n}\n\nvar getFieldsValues = (fieldsRef, shallowFieldsStateRef, excludeDisabled, search) => {\n  const output = {};\n\n  for (const name in fieldsRef.current) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : isArray(search) && search.find(data => name.startsWith(data)))) {\n      output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\n    }\n  }\n\n  return deepMerge(Object.assign({}, (shallowFieldsStateRef || {}).current || {}), transformToNestObject(output));\n};\n\nvar isSameError = (error, currentError) => isObject(error) && isObject(currentError) && error.type === currentError.type && error.message === currentError.message && Object.keys(error.types || {}).length === Object.keys(currentError.types || {}).length && Object.entries(error.types || {}).every(([key, value]) => (currentError.types || {})[key] === value);\n\nfunction shouldRenderBasedOnError({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation\n}) {\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n  return isValid && !!previousError || !isValid && !isSameError(previousError, error) || isValid && get(fieldsWithValidation, name) && !get(validFields, name);\n}\n\nvar isRegex = value => value instanceof RegExp;\n\nconst isValueMessage = value => isObject(value) && !isRegex(value);\n\nvar getValueAndMessage = validationData => isValueMessage(validationData) ? validationData : {\n  value: validationData,\n  message: ''\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isMessage = value => isString(value) || isObject(value) && isValidElement(value);\n\nfunction getValidateError(result, ref, type = 'validate') {\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n    return Object.assign(Object.assign({}, error), {\n      types: Object.assign(Object.assign({}, error && error.types ? error.types : {}), {\n        [type]: message || true\n      })\n    });\n  }\n\n  return {};\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, {\n  ref,\n  ref: {\n    type,\n    value\n  },\n  options,\n  required,\n  maxLength,\n  minLength,\n  min,\n  max,\n  pattern,\n  validate\n}, shallowFieldsStateRef) => {\n  const fields = fieldsRef.current;\n  const name = ref.name;\n  const error = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = Object.assign({\n      type: exceedMax ? maxType : minType,\n      message,\n      ref\n    }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n  };\n\n  if (required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid)) {\n    const {\n      value: requiredValue,\n      message: requiredMessage\n    } = isMessage(required) ? {\n      value: !!required,\n      message: required\n    } : getValueAndMessage(required);\n\n    if (requiredValue) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.required,\n        message: requiredMessage,\n        ref: isRadioOrCheckbox ? ((fields[name].options || [])[0] || {}).ref : ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const {\n      value: maxValue,\n      message: maxMessage\n    } = getValueAndMessage(max);\n    const {\n      value: minValue,\n      message: minMessage\n    } = getValueAndMessage(min);\n\n    if (type === 'number' || !type && !isNaN(value)) {\n      const valueNumber = ref.valueAsNumber || parseFloat(value);\n\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate = ref.valueAsDate || new Date(value);\n\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n    const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (pattern && !isEmpty) {\n    const {\n      value: patternValue,\n      message: patternMessage\n    } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {};\n\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(validateResult, validateRef, key);\n\n        if (validateError) {\n          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n\nconst getPath = (path, values) => {\n  const getInnerPath = (key, value, isObject) => {\n    const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return Object.entries(values).map(([key, value]) => getInnerPath(key, value, isObject(values))).flat(Infinity);\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\n  let value;\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || isArray(value)) {\n      getPath(fieldName, value).forEach(name => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\n\nvar skipValidation = ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar getFieldArrayParentName = name => name.substring(0, name.indexOf('['));\n\nfunction deepEqual(object1 = [], object2 = []) {\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (const key of keys1) {\n    const val1 = object1[key];\n    const val2 = object2[key];\n\n    if ((isObject(val1) || isArray(val1)) && (isObject(val2) || isArray(val2)) ? !deepEqual(val1, val2) : val1 !== val2) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\n\nvar isNameInFieldArray = (names, name) => [...names].some(current => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = element => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\n  const observer = new MutationObserver(() => {\n    for (const field of Object.values(fieldsRef.current)) {\n      if (field && field.options) {\n        for (const option of field.options) {\n          if (option && option.ref && isDetached(option.ref)) {\n            removeFieldEventListenerAndRef(field);\n          }\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched\n});\n\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useForm({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {},\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode\n} = {}) {\n  const fieldsRef = useRef({});\n  const fieldArrayDefaultValuesRef = useRef({});\n  const watchFieldsRef = useRef(new Set());\n  const useWatchFieldsRef = useRef({});\n  const useWatchRenderFunctionsRef = useRef({});\n  const fieldsWithValidationRef = useRef({});\n  const validFieldsRef = useRef({});\n  const defaultValuesRef = useRef(defaultValues);\n  const defaultValuesAtRenderRef = useRef({});\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const handleChangeRef = useRef();\n  const shallowFieldsStateRef = useRef(shouldUnregister ? {} : defaultValues);\n  const resetFieldArrayFunctionRef = useRef({});\n  const contextRef = useRef(context);\n  const resolverRef = useRef(resolver);\n  const fieldArrayNamesRef = useRef(new Set());\n  const modeRef = useRef(modeChecker(mode));\n  const {\n    isOnSubmit,\n    isOnTouch\n  } = modeRef.current;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = useState({\n    isDirty: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {}\n  });\n  const readFormStateRef = useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  const formStateRef = useRef(formState);\n  const observerRef = useRef();\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnChange: isReValidateOnChange\n  } = useRef(modeChecker(reValidateMode)).current;\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n  const updateFormState = useCallback((state = {}) => !isUnMount.current && setFormState(Object.assign(Object.assign({}, formStateRef.current), state)), []);\n  const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false, state = {}, isValid) => {\n    let shouldReRender = shouldRender || shouldRenderBasedOnError({\n      errors: formStateRef.current.errors,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    const previousError = get(formStateRef.current.errors, name);\n\n    if (error) {\n      unset(validFieldsRef.current, name);\n      shouldReRender = shouldReRender || !previousError || !isSameError(previousError, error);\n      set(formStateRef.current.errors, name, error);\n    } else {\n      if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n        set(validFieldsRef.current, name, true);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      unset(formStateRef.current.errors, name);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender) || !isEmptyObject(state)) {\n      updateFormState(Object.assign(Object.assign(Object.assign({}, state), {\n        errors: formStateRef.current.errors\n      }), resolverRef.current ? {\n        isValid: !!isValid\n      } : {}));\n    }\n  }, []);\n  const setFieldValue = useCallback(({\n    ref,\n    options\n  }, rawValue) => {\n    const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(ref) && options) {\n      options.forEach(({\n        ref: radioRef\n      }) => radioRef.checked = radioRef.value === value);\n    } else if (isFileInput(ref) && !isString(value)) {\n      ref.files = value;\n    } else if (isMultipleSelect(ref)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(({\n        ref: checkboxRef\n      }) => checkboxRef.checked = isArray(value) ? !!value.find(data => data === checkboxRef.value) : value === checkboxRef.value) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, []);\n  const updateAndGetDirtyState = useCallback((name, shouldRender = true) => {\n    if (!fieldsRef.current[name] || !readFormStateRef.current.isDirty && !readFormStateRef.current.dirtyFields) {\n      return {};\n    }\n\n    const isFieldDirty = defaultValuesAtRenderRef.current[name] !== getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n    const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const previousIsDirty = formStateRef.current.isDirty;\n    isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);\n    const state = {\n      isDirty: isFieldArray && !deepEqual(get(getValues(), getFieldArrayParentName(name)), get(defaultValuesRef.current, getFieldArrayParentName(name))) || !isEmptyObject(formStateRef.current.dirtyFields),\n      dirtyFields: formStateRef.current.dirtyFields\n    };\n    const isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name);\n\n    if (isChanged && shouldRender) {\n      formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\n      updateFormState(Object.assign({}, state));\n    }\n\n    return isChanged ? state : {};\n  }, []);\n  const executeValidation = useCallback(async (name, skipReRender) => {\n    if (fieldsRef.current[name]) {\n      const error = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];\n      shouldRenderBaseOnError(name, error, skipReRender);\n      return isUndefined(error);\n    }\n\n    return false;\n  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  const executeSchemaOrResolverValidation = useCallback(async names => {\n    const {\n      errors\n    } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n    const previousFormIsValid = formStateRef.current.isValid;\n\n    if (isArray(names)) {\n      const isInputsValid = names.map(name => {\n        const error = get(errors, name);\n        error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);\n        return !error;\n      }).every(Boolean);\n      updateFormState({\n        isValid: isEmptyObject(errors),\n        errors: formStateRef.current.errors\n      });\n      return isInputsValid;\n    } else {\n      const error = get(errors, names);\n      shouldRenderBaseOnError(names, error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\n      return !error;\n    }\n  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  const trigger = useCallback(async name => {\n    const fields = name || Object.keys(fieldsRef.current);\n\n    if (resolverRef.current) {\n      return executeSchemaOrResolverValidation(fields);\n    }\n\n    if (isArray(fields)) {\n      const result = await Promise.all(fields.map(async data => await executeValidation(data, null)));\n      updateFormState();\n      return result.every(Boolean);\n    }\n\n    return await executeValidation(fields);\n  }, [executeSchemaOrResolverValidation, executeValidation]);\n  const setInternalValues = useCallback((name, value, {\n    shouldDirty,\n    shouldValidate\n  }) => {\n    getPath(name, value).forEach(fieldName => {\n      const data = {};\n      const field = fieldsRef.current[fieldName];\n\n      if (field) {\n        set(data, name, value);\n        setFieldValue(field, get(data, fieldName));\n\n        if (shouldDirty) {\n          updateAndGetDirtyState(fieldName);\n        }\n\n        if (shouldValidate) {\n          trigger(fieldName);\n        }\n      }\n    });\n  }, [trigger, setFieldValue, updateAndGetDirtyState]);\n  const setInternalValue = useCallback((name, value, config) => {\n    if (fieldsRef.current[name]) {\n      setFieldValue(fieldsRef.current[name], value);\n      config.shouldDirty && updateAndGetDirtyState(name);\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value, config);\n\n      if (isNameInFieldArray(fieldArrayNamesRef.current, name) || fieldArrayNamesRef.current.has(name)) {\n        const fieldArrayParentName = getFieldArrayParentName(name) || name;\n        fieldArrayDefaultValuesRef.current[fieldArrayParentName] = value;\n        resetFieldArrayFunctionRef.current[fieldArrayParentName]({\n          [name]: value\n        });\n      }\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n  }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\n\n  const isFieldWatched = name => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = (name, found = true) => {\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (const key in useWatchFieldsRef.current) {\n        if (!name || useWatchFieldsRef.current[key].has(name) || useWatchFieldsRef.current[key].has(getFieldArrayParentName(name)) || !useWatchFieldsRef.current[key].size) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(name, value, config = {}) {\n    setInternalValue(name, value, config);\n\n    if (isFieldWatched(name)) {\n      updateFormState();\n    }\n\n    renderWatchedInputs(name);\n\n    if (config.shouldValidate) {\n      trigger(name);\n    }\n  }\n\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : async ({\n    type,\n    target\n  }) => {\n    const name = target.name;\n    const field = fieldsRef.current[name];\n    let error;\n    let isValid;\n\n    if (field) {\n      const isBlurEvent = type === EVENTS.BLUR;\n      const shouldSkipValidation = skipValidation(Object.assign({\n        isBlurEvent,\n        isReValidateOnChange,\n        isReValidateOnBlur,\n        isTouched: !!get(formStateRef.current.touched, name),\n        isSubmitted: formStateRef.current.isSubmitted\n      }, modeRef.current));\n      let state = updateAndGetDirtyState(name, false);\n      let shouldRender = !isEmptyObject(state) || isFieldWatched(name);\n\n      if (isBlurEvent && !get(formStateRef.current.touched, name) && readFormStateRef.current.touched) {\n        set(formStateRef.current.touched, name, true);\n        state = Object.assign(Object.assign({}, state), {\n          touched: formStateRef.current.touched\n        });\n      }\n\n      if (shouldSkipValidation) {\n        renderWatchedInputs(name);\n        return (!isEmptyObject(state) || shouldRender && isEmptyObject(state)) && updateFormState(state);\n      }\n\n      if (resolverRef.current) {\n        const {\n          errors\n        } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n        const previousFormIsValid = formStateRef.current.isValid;\n        error = get(errors, name);\n        isValid = isEmptyObject(errors);\n\n        if (previousFormIsValid !== isValid) {\n          shouldRender = true;\n        }\n      } else {\n        error = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];\n      }\n\n      renderWatchedInputs(name);\n      shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n    }\n  };\n\n  function getValues(payload) {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (isArray(payload)) {\n      const data = {};\n\n      for (const name of payload) {\n        set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      }\n\n      return data;\n    }\n\n    return getFieldsValues(fieldsRef, shallowFieldsStateRef);\n  }\n\n  const validateResolver = useCallback(async (values = {}) => {\n    const {\n      errors\n    } = await resolverRef.current(Object.assign(Object.assign(Object.assign({}, defaultValuesRef.current), getValues()), values), contextRef.current, isValidateAllFieldCriteria);\n    const previousFormIsValid = formStateRef.current.isValid;\n    const isValid = isEmptyObject(errors);\n\n    if (previousFormIsValid !== isValid) {\n      updateFormState({\n        isValid\n      });\n    }\n  }, [isValidateAllFieldCriteria]);\n  const removeFieldEventListener = useCallback((field, forceDelete) => findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete), [shouldUnregister]);\n  const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (field) {\n      removeFieldEventListener(field, forceDelete);\n\n      if (shouldUnregister && !filterOutFalsy(field.options || []).length) {\n        delete defaultValuesAtRenderRef.current[field.ref.name];\n        unset(validFieldsRef.current, field.ref.name);\n        unset(fieldsWithValidationRef.current, field.ref.name);\n        unset(formStateRef.current.errors, field.ref.name);\n        unset(formStateRef.current.dirtyFields, field.ref.name);\n        unset(formStateRef.current.touched, field.ref.name);\n        updateFormState({\n          errors: formStateRef.current.errors,\n          isDirty: !isEmptyObject(formStateRef.current.dirtyFields),\n          dirtyFields: formStateRef.current.dirtyFields,\n          touched: formStateRef.current.touched\n        });\n        resolverRef.current && validateResolver();\n      }\n    }\n  }, [validateResolver, removeFieldEventListener]);\n\n  function clearErrors(name) {\n    name && (isArray(name) ? name : [name]).forEach(inputName => fieldsRef.current[inputName] ? delete formStateRef.current.errors[inputName] : unset(formStateRef.current.errors, inputName));\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {}\n    });\n  }\n\n  function setError(name, error = {}) {\n    const ref = (fieldsRef.current[name] || {}).ref;\n    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {\n      ref\n    }));\n    updateFormState({\n      isValid: false,\n      errors: formStateRef.current.errors\n    });\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\n    const watchFields = watchId ? useWatchFieldsRef.current[watchId] : watchFieldsRef.current;\n    const combinedDefaultValues = isUndefined(defaultValue) ? defaultValuesRef.current : defaultValue;\n    const fieldValues = getFieldsValues(fieldsRef, shallowFieldsStateRef, false, fieldNames);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (fieldNames) {\n        const fieldRefNames = Object.keys(fieldsRef.current);\n\n        if (fieldRefNames.length) {\n          (isArray(fieldNames) ? fieldNames : [fieldNames]).forEach(name => {\n            if (!fieldRefNames.find(fieldName => fieldName.startsWith(name))) {\n              console.warn(`📋 watched fields: ${fieldNames} are not found.`);\n            }\n          });\n        }\n      }\n    }\n\n    if (isString(fieldNames)) {\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(defaultValue) ? get(combinedDefaultValues, fieldNames) : defaultValue, true);\n    }\n\n    if (isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)\n      }), {});\n    }\n\n    if (isUndefined(watchId)) {\n      isWatchAllRef.current = true;\n    }\n\n    return transformToNestObject(!isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues);\n  }, []);\n\n  function watch(fieldNames, defaultValue) {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(name) {\n    (isArray(name) ? name : [name]).forEach(fieldName => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\n  }\n\n  function registerFieldRef(ref, validateOptions = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn('📋 Field is missing `name` attribute', ref, `https://react-hook-form.com/api#useForm`);\n      }\n\n      if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) && !RegExp(`^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(ref.name)) {\n        return console.warn('📋 `name` prop should be in object shape: name=\"test[index].name\"', ref, 'https://react-hook-form.com/api#useFieldArray');\n      }\n    }\n\n    const {\n      name,\n      type,\n      value\n    } = ref;\n    const fieldRefAndValidationOptions = Object.assign({\n      ref\n    }, validateOptions);\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n\n    const compareRef = currentRef => isWeb && (!isHTMLElement(ref) || currentRef === ref);\n\n    let field = fields[name];\n    let isEmptyDefaultValue = true;\n    let isFieldArray;\n    let defaultValue;\n\n    if (field && (isRadioOrCheckbox ? isArray(field.options) && filterOutFalsy(field.options).find(option => {\n      return value === option.ref.value && compareRef(option.ref);\n    }) : compareRef(field.ref))) {\n      fields[name] = Object.assign(Object.assign({}, field), validateOptions);\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [...filterOutFalsy(field && field.options || []), {\n          ref\n        }],\n        ref: {\n          type,\n          name\n        }\n      }, validateOptions) : Object.assign({}, fieldRefAndValidationOptions);\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n    const isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(isEmptyUnmountFields ? defaultValuesRef.current : shallowFieldsStateRef.current, name);\n      isEmptyDefaultValue = isUndefined(defaultValue);\n      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(field, defaultValue);\n      }\n    }\n\n    if (resolver && !isFieldArray && readFormStateRef.current.isValid) {\n      validateResolver();\n    } else if (!isEmptyObject(validateOptions)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then(error => {\n          const previousFormIsValid = formStateRef.current.isValid;\n          isEmptyObject(error) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);\n\n          if (previousFormIsValid !== isEmptyObject(error)) {\n            updateFormState();\n          }\n        });\n      }\n    }\n\n    if (!defaultValuesAtRenderRef.current[name] && !(isFieldArray && isEmptyDefaultValue)) {\n      const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n      defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? isObject(fieldValue) ? Object.assign({}, fieldValue) : fieldValue : defaultValue;\n    }\n\n    if (type) {\n      attachEventListeners(isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\n    }\n  }\n\n  function register(refOrValidationOptions, rules) {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldRef({\n          name: refOrValidationOptions\n        }, rules);\n      } else if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\n        registerFieldRef(refOrValidationOptions, rules);\n      } else {\n        return ref => ref && registerFieldRef(ref, refOrValidationOptions);\n      }\n    }\n  }\n\n  const handleSubmit = useCallback((onValid, onInvalid) => async e => {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n      e.persist();\n    }\n\n    let fieldErrors = {};\n    let fieldValues = getFieldsValues(fieldsRef, shallowFieldsStateRef, true);\n\n    if (readFormStateRef.current.isSubmitting) {\n      updateFormState({\n        isSubmitting: true\n      });\n    }\n\n    try {\n      if (resolverRef.current) {\n        const {\n          errors,\n          values\n        } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\n        formStateRef.current.errors = errors;\n        fieldErrors = errors;\n        fieldValues = values;\n      } else {\n        for (const field of Object.values(fieldsRef.current)) {\n          if (field) {\n            const {\n              ref: {\n                name\n              }\n            } = field;\n            const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\n\n            if (fieldError[name]) {\n              set(fieldErrors, name, fieldError[name]);\n              unset(validFieldsRef.current, name);\n            } else if (get(fieldsWithValidationRef.current, name)) {\n              unset(formStateRef.current.errors, name);\n              set(validFieldsRef.current, name, true);\n            }\n          }\n        }\n      }\n\n      if (isEmptyObject(fieldErrors) && Object.keys(formStateRef.current.errors).every(name => name in fieldsRef.current)) {\n        updateFormState({\n          errors: {},\n          isSubmitting: true\n        });\n        await onValid(fieldValues, e);\n      } else {\n        formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\n\n        if (onInvalid) {\n          await onInvalid(fieldErrors, e);\n        }\n\n        if (shouldFocusError) {\n          focusOnErrorField(fieldsRef.current, fieldErrors);\n        }\n      }\n    } finally {\n      updateFormState({\n        isSubmitted: true,\n        isSubmitting: false,\n        isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n        errors: formStateRef.current.errors,\n        submitCount: formStateRef.current.submitCount + 1\n      });\n    }\n  }, [shouldFocusError, isValidateAllFieldCriteria]);\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields\n  }) => {\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    updateFormState({\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isSubmitting: false,\n      isSubmitSuccessful: false,\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isValid: isValid ? formStateRef.current.isValid : true,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {}\n    });\n  };\n\n  const reset = (values, omitResetState = {}) => {\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const {\n            ref,\n            options\n          } = field;\n          const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options) ? options[0].ref : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = values || Object.assign({}, defaultValuesRef.current);\n\n    if (values) {\n      renderWatchedInputs('');\n    }\n\n    shallowFieldsStateRef.current = shouldUnregister ? {} : values || {};\n    Object.values(resetFieldArrayFunctionRef.current).forEach(resetFieldArray => isFunction(resetFieldArray) && resetFieldArray());\n    resetRefs(omitResetState);\n  };\n\n  observerRef.current = observerRef.current || !isWeb ? observerRef.current : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n  useEffect(() => {\n    isUnMount.current = false;\n    return () => {\n      isUnMount.current = true;\n\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      fieldsRef.current && Object.values(fieldsRef.current).forEach(field => removeFieldEventListenerAndRef(field, true));\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors);\n  }\n\n  const commonProps = {\n    trigger,\n    setValue: useCallback(setValue, [setInternalValue, trigger]),\n    getValues: useCallback(getValues, []),\n    register: useCallback(register, [defaultValuesRef.current]),\n    unregister: useCallback(unregister, [])\n  };\n  const control = Object.assign({\n    removeFieldEventListener,\n    renderWatchedInputs,\n    watchInternal,\n    mode: modeRef.current,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange\n    },\n    fieldsRef,\n    isWatchAllRef,\n    watchFieldsRef,\n    resetFieldArrayFunctionRef,\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    fieldArrayDefaultValuesRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    readFormStateRef,\n    formStateRef,\n    defaultValuesRef,\n    shallowFieldsStateRef,\n    updateFormState,\n    shouldUnregister,\n    validateResolver: resolver ? validateResolver : undefined\n  }, commonProps);\n  return Object.assign({\n    watch,\n    control,\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: (obj, prop) => {\n        if (process.env.NODE_ENV !== 'production' && prop === 'isValid' && isOnSubmit) {\n          console.warn('📋 `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\n        }\n\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n\n        return undefined;\n      }\n    }) : formState,\n    handleSubmit,\n    reset: useCallback(reset, []),\n    clearErrors: useCallback(clearErrors, []),\n    setError: useCallback(setError, []),\n    errors: formState.errors\n  }, commonProps);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nconst FormContext = createContext(null);\nFormContext.displayName = 'RHFContext';\n\nconst useFormContext = () => useContext(FormContext);\n\nconst FormProvider = _a => {\n  var {\n    children\n  } = _a,\n      props = __rest(_a, [\"children\"]);\n\n  return createElement(FormContext.Provider, {\n    value: Object.assign({}, props)\n  }, children);\n};\n\nvar generateId = () => {\n  const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nconst removeAt = (data, index) => [...data.slice(0, index), ...data.slice(index + 1)];\n\nfunction removeAtIndexes(data, index) {\n  let k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return filterOutFalsy(data);\n}\n\nvar removeArrayAt = (data, index) => isUndefined(index) ? [] : isArray(index) ? removeAtIndexes(data, index) : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => {\n  if (isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n\nfunction prepend(data, value) {\n  return [...(isArray(value) ? value : [value || undefined]), ...data];\n}\n\nfunction insert(data, index, value) {\n  return [...data.slice(0, index), ...(isArray(value) ? value : [value || undefined]), ...data.slice(index)];\n}\n\nvar fillEmptyArray = value => isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction mapValueToBoolean(value) {\n  if (isObject(value)) {\n    const object = {};\n\n    for (const key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nvar filterBooleanArray = value => (isArray(value) ? value : [value]).map(mapValueToBoolean).flat();\n\nconst appendId = (value, keyName) => Object.assign({\n  [keyName]: generateId()\n}, value);\n\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map(value => appendId(value, keyName));\n\nconst useFieldArray = ({\n  control,\n  name,\n  keyName = 'id'\n}) => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray');\n    }\n\n    if (!name) {\n      console.warn('📋 useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray');\n    }\n  }\n\n  const focusIndexRef = useRef(-1);\n  const {\n    isWatchAllRef,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    formStateRef,\n    formStateRef: {\n      current: {\n        dirtyFields,\n        touched\n      }\n    },\n    shallowFieldsStateRef,\n    updateFormState,\n    readFormStateRef,\n    watchFieldsRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n    validateResolver,\n    renderWatchedInputs,\n    getValues\n  } = control || methods.control;\n  const fieldArrayParentName = getFieldArrayParentName(name);\n\n  const getDefaultValues = () => [...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName) ? get(fieldArrayDefaultValuesRef.current, name, []) : get(defaultValuesRef.current, name, []))];\n\n  const memoizedDefaultValues = useRef(getDefaultValues());\n  const [fields, setFields] = useState(mapIds(memoizedDefaultValues.current, keyName));\n  const allFields = useRef(fields);\n\n  const getCurrentFieldsValues = () => get(getValues() || {}, name, allFields.current).map((item, index) => Object.assign(Object.assign({}, allFields.current[index]), item));\n\n  allFields.current = fields;\n  fieldArrayNamesRef.current.add(name);\n\n  if (!get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\n    set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, get(defaultValuesRef.current, fieldArrayParentName));\n  }\n\n  const appendValueWithKey = values => values.map(value => appendId(value, keyName));\n\n  const setFieldAndValidState = fieldsValues => {\n    setFields(fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = {};\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const getIsDirtyState = flagOrFields => (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && (isUndefined(flagOrFields) || !deepEqual(flagOrFields.map((_a = {}) => {\n    var _b = keyName,\n        omitted = _a[_b],\n        rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n    return rest;\n  }), get(defaultValuesRef.current, name)));\n\n  const resetFields = () => {\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\n        removeFieldEventListener(fieldsRef.current[key], true);\n      }\n    }\n  };\n\n  const cleanup = ref => !filterOutFalsy(get(ref, name, [])).length && unset(ref, name);\n\n  const batchStateUpdate = (method, args, isDirty = true, shouldSet = true, shouldUpdateValid = false) => {\n    if (get(shallowFieldsStateRef.current, name)) {\n      const output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n      cleanup(shallowFieldsStateRef.current);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      const output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\n      cleanup(fieldArrayDefaultValuesRef.current);\n    }\n\n    if (isArray(get(formStateRef.current.errors, name))) {\n      const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touched && get(touched, name)) {\n      const output = method(get(touched, name), args.argA, args.argB);\n      shouldSet && set(touched, name, output);\n      cleanup(touched);\n    }\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      const output = method(get(dirtyFields, name, []), args.argC, args.argD);\n      shouldSet && set(dirtyFields, name, output);\n      cleanup(dirtyFields);\n    }\n\n    if (shouldUpdateValid && readFormStateRef.current.isValid && !validateResolver) {\n      set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\n      cleanup(validFieldsRef.current);\n      set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    updateFormState({\n      errors: formStateRef.current.errors,\n      dirtyFields,\n      isDirty,\n      touched\n    });\n  };\n\n  const append = (value, shouldFocus = true) => {\n    setFieldAndValidState([...allFields.current, ...(isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)])]);\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      set(dirtyFields, name, [...(isArray(get(dirtyFields, name)) ? get(dirtyFields, name) : fillEmptyArray(allFields.current)), ...filterBooleanArray(value)]);\n      updateFormState({\n        isDirty: true,\n        dirtyFields\n      });\n    }\n\n    focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\n    renderWatchedInputs(name);\n  };\n\n  const prepend$1 = (value, shouldFocus = true) => {\n    const emptyArray = fillEmptyArray(value);\n    setFieldAndValidState(prepend(getCurrentFieldsValues(), isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n    resetFields();\n    batchStateUpdate(prepend, {\n      argA: emptyArray,\n      argC: filterBooleanArray(value)\n    });\n    renderWatchedInputs(name);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = index => {\n    const fieldValues = getCurrentFieldsValues();\n    setFieldAndValidState(removeArrayAt(fieldValues, index));\n    resetFields();\n    batchStateUpdate(removeArrayAt, {\n      argA: index,\n      argC: index\n    }, getIsDirtyState(removeArrayAt(fieldValues, index)), true, true);\n    renderWatchedInputs(name);\n  };\n\n  const insert$1 = (index, value, shouldFocus = true) => {\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n    setFieldAndValidState(insert(fieldValues, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n    resetFields();\n    batchStateUpdate(insert, {\n      argA: index,\n      argB: emptyArray,\n      argC: index,\n      argD: filterBooleanArray(value)\n    }, getIsDirtyState(insert(fieldValues, index)));\n    renderWatchedInputs(name);\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA, indexB) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(swapArrayAt, {\n      argA: indexA,\n      argB: indexB,\n      argC: indexA,\n      argD: indexB\n    }, getIsDirtyState(fieldValues), false);\n    renderWatchedInputs(name);\n  };\n\n  const move = (from, to) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(moveArrayAt, {\n      argA: from,\n      argB: to,\n      argC: from,\n      argD: to\n    }, getIsDirtyState(fieldValues), false);\n    renderWatchedInputs(name);\n  };\n\n  const reset = data => {\n    resetFields();\n    !data && unset(fieldArrayDefaultValuesRef.current, name);\n    unset(shallowFieldsStateRef.current, name);\n    memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\n    setFields(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  useEffect(() => {\n    const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      defaultValues.pop();\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues);\n    }\n\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else if (watchFieldsRef) {\n      let shouldRenderUseWatch = true;\n\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          updateFormState();\n          shouldRenderUseWatch = false;\n          break;\n        }\n      }\n\n      shouldRenderUseWatch && renderWatchedInputs(name);\n    }\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n\n        if (key.startsWith(`${name}[${focusIndexRef.current}]`) && field.ref.focus) {\n          field.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n  useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = reset;\n    }\n\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [name]),\n    insert: useCallback(insert$1, [name]),\n    fields\n  };\n};\n\nfunction useWatch({\n  control,\n  name,\n  defaultValue\n}) {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch');\n    }\n\n    if (name === '') {\n      console.warn('📋 useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch');\n    }\n  }\n\n  const {\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    watchInternal,\n    defaultValuesRef\n  } = control || methods.control;\n  const [value, setValue] = useState(isUndefined(defaultValue) ? isString(name) ? get(defaultValuesRef.current, name) : isArray(name) ? name.reduce((previous, inputName) => Object.assign(Object.assign({}, previous), {\n    [inputName]: get(defaultValuesRef.current, inputName)\n  }), {}) : defaultValuesRef.current : defaultValue);\n  const idRef = useRef();\n  const defaultValueRef = useRef(defaultValue);\n  const updateWatchValue = useCallback(() => {\n    const value = watchInternal(name, defaultValueRef.current, idRef.current);\n    setValue(isObject(value) ? Object.assign({}, value) : isArray(value) ? [...value] : value);\n  }, [setValue, watchInternal, defaultValueRef, name, idRef]);\n  useEffect(() => {\n    const id = idRef.current = generateId();\n    const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    const watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(name, defaultValueRef.current, id);\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [name, updateWatchValue, useWatchRenderFunctionsRef, useWatchFieldsRef, watchInternal, defaultValueRef]);\n  return isUndefined(value) ? defaultValue : value;\n}\n\nvar getInputValue = event => isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isUndefined(event.target.value) ? event.target.checked : event.target.value;\n\nconst Controller = _a => {\n  var {\n    name,\n    rules,\n    as,\n    render,\n    defaultValue,\n    control,\n    onFocus\n  } = _a,\n      rest = __rest(_a, [\"name\", \"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\n\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production' && !control && !methods) {\n    throw new Error('📋 Controller is missing `control` prop. https://react-hook-form.com/api#Controller');\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange\n    },\n    formStateRef: {\n      current: {\n        isSubmitted,\n        touched\n      }\n    },\n    updateFormState,\n    readFormStateRef,\n    fieldsRef,\n    fieldArrayNamesRef,\n    shallowFieldsStateRef\n  } = control || methods.control;\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n  const getInitialValue = () => !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray ? get(shallowFieldsStateRef.current, name) : isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue;\n\n  const [value, setInputStateValue] = useState(getInitialValue());\n  const valueRef = useRef(value);\n  const onFocusRef = useRef(onFocus);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined(value)) {\n      console.warn(`📋 ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`);\n    }\n\n    if (!as && !render || as && render) {\n      console.warn(`📋 ${name} Controller should use either the 'as' or 'render' prop, not both. https://react-hook-form.com/api#Controller`);\n    }\n\n    if (!isNotFieldArray && isUndefined(defaultValue)) {\n      console.warn('📋 Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller');\n    }\n  }\n\n  const shouldValidate = isBlurEvent => !skipValidation(Object.assign({\n    isBlurEvent,\n    isReValidateOnBlur,\n    isReValidateOnChange,\n    isSubmitted,\n    isTouched: !!get(touched, name)\n  }, mode));\n\n  const commonTask = ([event]) => {\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  const registerField = useCallback(() => {\n    if (process.env.NODE_ENV !== 'production' && !name) {\n      return console.warn('📋 Field is missing `name` prop. https://react-hook-form.com/api#Controller');\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = Object.assign({\n        ref: fieldsRef.current[name].ref\n      }, rules);\n    } else {\n      register(Object.defineProperty({\n        name,\n        focus: onFocusRef.current\n      }, VALUE, {\n        set(data) {\n          setInputStateValue(data);\n          valueRef.current = data;\n        },\n\n        get() {\n          return valueRef.current;\n        }\n\n      }), rules);\n\n      if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  }, [rules, name, register]);\n  useEffect(() => () => {\n    !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\n  }, [unregister, name, fieldArrayNamesRef]);\n  useEffect(() => {\n    registerField();\n  }, [registerField]);\n  useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  const onBlur = () => {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched\n      });\n    }\n\n    if (shouldValidate(true)) {\n      trigger(name);\n    }\n  };\n\n  const onChange = (...event) => setValue(name, commonTask(event), {\n    shouldValidate: shouldValidate(),\n    shouldDirty: true\n  });\n\n  const props = Object.assign(Object.assign({}, rest), {\n    onChange,\n    onBlur,\n    name,\n    value\n  });\n  return as ? isValidElement(as) ? cloneElement(as, props) : createElement(as, props) : render ? render({\n    onChange,\n    onBlur,\n    value,\n    name\n  }) : null;\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useFieldArray, useForm, useFormContext, useWatch };","map":{"version":3,"sources":["../src/utils/isHTMLElement.ts","../src/constants.ts","../src/logic/attachEventListeners.ts","../src/utils/isNullOrUndefined.ts","../src/utils/isArray.ts","../src/utils/isObject.ts","../src/utils/isKey.ts","../src/utils/stringToPath.ts","../src/utils/set.ts","../src/logic/transformToNestObject.ts","../src/utils/isUndefined.ts","../src/utils/filterOutFalsy.ts","../src/utils/get.ts","../src/logic/focusOnErrorField.ts","../src/logic/removeAllEventListeners.ts","../src/logic/getRadioValue.ts","../src/logic/getMultipleSelectValue.ts","../src/utils/isRadioInput.ts","../src/utils/isFileInput.ts","../src/utils/isCheckBoxInput.ts","../src/utils/isMultipleSelect.ts","../src/logic/getCheckboxValue.ts","../src/logic/getFieldValue.ts","../src/utils/isDetached.ts","../src/utils/isEmptyObject.ts","../src/utils/isBoolean.ts","../src/utils/unset.ts","../src/logic/findRemovedFieldAndRemoveListener.ts","../src/utils/isString.ts","../src/utils/isPrimitive.ts","../src/utils/deepMerge.ts","../src/logic/getFieldsValues.ts","../src/utils/isSameError.ts","../src/logic/shouldRenderBasedOnError.ts","../src/utils/isRegex.ts","../src/logic/getValueAndMessage.ts","../src/utils/isFunction.ts","../src/utils/isMessage.ts","../src/logic/getValidateError.ts","../src/logic/appendErrors.ts","../src/logic/validateField.ts","../src/utils/getPath.ts","../src/logic/assignWatchFields.ts","../src/logic/skipValidation.ts","../src/logic/getFieldArrayParentName.ts","../src/utils/deepEqual.ts","../src/logic/isNameInFieldArray.ts","../src/utils/isSelectInput.ts","../src/utils/onDomRemove.ts","../src/utils/validationModeChecker.ts","../src/utils/isRadioOrCheckbox.ts","../src/useForm.ts","../src/useFormContext.tsx","../src/logic/generateId.ts","../src/utils/remove.ts","../src/utils/move.ts","../src/utils/swap.ts","../src/utils/prepend.ts","../src/utils/insert.ts","../src/utils/fillEmptyArray.ts","../src/utils/filterBooleanArray.ts","../src/useFieldArray.ts","../src/useWatch.ts","../src/logic/getInputValue.ts","../src/controller.tsx"],"names":["isCheckBox","getFieldsValue","React.useRef","React.useState","React.useCallback","React.useEffect","React.createContext","React.useContext","React.createElement","prepend","prependAt","insert","insertAt","React.isValidElement","React.cloneElement"],"mappings":"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","sourcesContent":["export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { ValidationMode } from './types';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all',\n};\n\nexport const VALUE = 'value';\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Field } from '../types';\n\nexport default function attachEventListeners(\n  { ref }: Field,\n  shouldAttachChangeEvent?: boolean,\n  handleChange?: EventListenerOrEventListenerObject,\n): void {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(\n      shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT,\n      handleChange,\n    );\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n","export default (value: unknown): value is null | undefined => value == null;\n","export default <T>(value: unknown): value is T[] => Array.isArray(value);\n","import isNullOrUndefined from './isNullOrUndefined';\nimport isArray from './isArray';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !isArray(value) &&\n  isObjectType(value) &&\n  !(value instanceof Date);\n","import isArray from './isArray';\n\nexport default (value: [] | string) =>\n  !isArray(value) &&\n  (/^\\w*$/.test(value) ||\n    !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n","export default (input: string): (string | number)[] => {\n  const result: (string | number)[] = [];\n\n  input.replace(\n    /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n    (\n      match: string,\n      mathNumber: string,\n      mathQuote: string,\n      originalString: string,\n    ): any => {\n      result.push(\n        mathQuote\n          ? originalString.replace(/\\\\(\\\\)?/g, '$1')\n          : mathNumber || match,\n      );\n    },\n  );\n\n  return result;\n};\n","import isObject from './isObject';\nimport isArray from './isArray';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport { FieldValues } from '../types';\n\nexport default function set(object: FieldValues, path: string, value: unknown) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import set from '../utils/set';\nimport isKey from '../utils/isKey';\nimport { FieldValues } from '../types';\n\nexport default (data: FieldValues): any =>\n  Object.entries(data).reduce(\n    (previous: FieldValues, [key, value]): FieldValues => {\n      if (!isKey(key)) {\n        set(previous, key, value);\n        return previous;\n      }\n\n      return { ...previous, [key]: value };\n    },\n    {},\n  );\n","export default (val: unknown): val is undefined => val === undefined;\n","export default (value: any[]) => value.filter(Boolean);\n","import isUndefined from './isUndefined';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport filterOutFalsy from './filterOutFalsy';\n\nexport default (obj: any, path: string, defaultValue?: unknown) => {\n  const result = filterOutFalsy(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","import get from '../utils/get';\nimport { FieldErrors, FieldRefs } from '../types';\n\nexport default <TFieldValues>(\n  fields: FieldRefs<TFieldValues>,\n  fieldErrors: FieldErrors<TFieldValues>,\n) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          field.ref.focus();\n\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n\n          break;\n        }\n      }\n    }\n  }\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Ref } from '../types';\n\nexport default (\n  ref: Ref,\n  validateWithStateUpdate: EventListenerOrEventListenerObject,\n): void => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n","import isArray from '../utils/isArray';\nimport { RadioOrCheckboxOption } from '../types';\n\ntype RadioFieldResult = {\n  isValid: boolean;\n  value: number | string;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: '',\n};\n\nexport default (options?: RadioOrCheckboxOption[]): RadioFieldResult =>\n  isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.ref.checked\n            ? {\n                isValid: true,\n                value: option.ref.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","import isArray from '../utils/isArray';\nimport isUndefined from '../utils/isUndefined';\nimport { RadioOrCheckboxOption } from '../types';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: RadioOrCheckboxOption[]): CheckboxFieldResult => {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.ref.checked)\n        .map(({ ref: { value } }) => value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    const { checked, value, attributes } = options[0].ref;\n\n    return checked\n      ? attributes && !isUndefined((attributes as any).value)\n        ? isUndefined(value) || value === ''\n          ? validResult\n          : { value: value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport get from '../utils/get';\nimport isFileInput from '../utils/isFileInput';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport getCheckboxValue from './getCheckboxValue';\nimport { FieldRefs, FieldValues, InternalFieldName } from '../types';\n\nexport default function getFieldValue<TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  name: InternalFieldName<TFieldValues>,\n  shallowFieldsStateRef?: React.MutableRefObject<FieldValues>,\n  excludeDisabled?: boolean,\n) {\n  const field = fieldsRef.current[name]!;\n\n  if (field) {\n    const {\n      ref: { value, disabled },\n      ref,\n    } = field;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n","import { Ref } from '../types';\n\nexport default function isDetached(element: Ref): boolean {\n  if (!element) {\n    return true;\n  }\n\n  if (\n    !(element instanceof HTMLElement) ||\n    element.nodeType === Node.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n\n  return isDetached(element.parentNode as Ref);\n}\n","import isObject from './isObject';\nimport { EmptyObject } from '../types';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import isArray from './isArray';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport isEmptyObject from './isEmptyObject';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\nimport isBoolean from './isBoolean';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const path = updatePath.slice(0, -1);\n  const length = path.length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (isArray(objectRef) &&\n            !objectRef.filter(\n              (data) =>\n                (isObject(data) && !isEmptyObject(data)) || isBoolean(data),\n            ).length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import * as React from 'react';\nimport removeAllEventListeners from './removeAllEventListeners';\nimport getFieldValue from './getFieldValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport set from '../utils/set';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isDetached from '../utils/isDetached';\nimport isArray from '../utils/isArray';\nimport unset from '../utils/unset';\nimport filterOutFalsy from '../utils/filterOutFalsy';\nimport isUndefined from '../utils/isUndefined';\nimport { Field, FieldRefs, FieldValues, Ref } from '../types';\n\nconst isSameRef = (fieldValue: Field, ref: Ref) =>\n  fieldValue && fieldValue.ref === ref;\n\nexport default function findRemovedFieldAndRemoveListener<\n  TFieldValues extends FieldValues\n>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  handleChange: ({ type, target }: Event) => Promise<void | boolean>,\n  field: Field,\n  shallowFieldsStateRef: React.MutableRefObject<FieldValues>,\n  shouldUnregister?: boolean,\n  forceDelete?: boolean,\n): void {\n  const {\n    ref,\n    ref: { name, type },\n  } = field;\n  const fieldRef = fieldsRef.current[name] as Field;\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n\n    if (!isUndefined(value)) {\n      set(shallowFieldsStateRef.current, name, value);\n    }\n  }\n\n  if (!type) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    const { options } = fieldRef;\n\n    if (isArray(options) && options.length) {\n      filterOutFalsy(options).forEach((option, index): void => {\n        const { ref } = option;\n        if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n          unset(options, `[${index}]`);\n        }\n      });\n\n      if (options && !filterOutFalsy(options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    delete fieldsRef.current[name];\n  }\n}\n","export default (value: unknown): value is string => typeof value === 'string';\n","import isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\nimport { Primitive } from '../types';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import isObject from './isObject';\nimport isArray from './isArray';\nimport isPrimitive from './isPrimitive';\n\nexport function deepMerge<\n  T extends Record<keyof T, any>,\n  U extends Record<keyof U, any>\n>(target: T, source: U): T & U {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      if (\n        (isObject(targetValue) && isObject(sourceValue)) ||\n        (isArray(targetValue) && isArray(sourceValue))\n      ) {\n        target[key] = deepMerge(targetValue, sourceValue);\n      } else {\n        target[key] = sourceValue;\n      }\n    } catch {}\n  }\n\n  return target;\n}\n","import * as React from 'react';\nimport getFieldValue from './getFieldValue';\nimport isString from '../utils/isString';\nimport isArray from '../utils/isArray';\nimport { deepMerge } from '../utils/deepMerge';\nimport isUndefined from '../utils/isUndefined';\nimport { InternalFieldName, FieldValues, FieldRefs } from '../types';\nimport transformToNestObject from './transformToNestObject';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  shallowFieldsStateRef?: React.MutableRefObject<Record<string, any>>,\n  excludeDisabled?: boolean,\n  search?:\n    | InternalFieldName<TFieldValues>\n    | InternalFieldName<TFieldValues>[]\n    | { nest: boolean },\n) => {\n  const output = {} as TFieldValues;\n\n  for (const name in fieldsRef.current) {\n    if (\n      isUndefined(search) ||\n      (isString(search)\n        ? name.startsWith(search)\n        : isArray(search) && search.find((data) => name.startsWith(data)))\n    ) {\n      output[name as InternalFieldName<TFieldValues>] = getFieldValue(\n        fieldsRef,\n        name,\n        undefined,\n        excludeDisabled,\n      );\n    }\n  }\n\n  return deepMerge(\n    { ...((shallowFieldsStateRef || {}).current || {}) },\n    transformToNestObject(output),\n  );\n};\n","import isObject from './isObject';\nimport { FieldError } from '../types';\n\nexport default (error: FieldError, currentError?: FieldError): boolean =>\n  isObject(error) &&\n  isObject(currentError) &&\n  error.type === currentError.type &&\n  error.message === currentError.message &&\n  Object.keys(error.types || {}).length ===\n    Object.keys(currentError.types || {}).length &&\n  Object.entries(error.types || {}).every(\n    ([key, value]) => (currentError.types || {})[key] === value,\n  );\n","import isSameError from '../utils/isSameError';\nimport get from '../utils/get';\nimport isUndefined from '../utils/isUndefined';\nimport {\n  FieldValues,\n  InternalFieldName,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n  FieldError,\n} from '../types';\n\nexport default function shouldRenderBasedOnError<\n  TFieldValues extends FieldValues\n>({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation,\n}: {\n  errors: FieldErrors<TFieldValues>;\n  error: FieldError | undefined;\n  name: InternalFieldName<TFieldValues>;\n  validFields: FieldNamesMarkedBoolean<TFieldValues>;\n  fieldsWithValidation: FieldNamesMarkedBoolean<TFieldValues>;\n}): boolean {\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n\n  return (\n    (isValid && !!previousError) ||\n    (!isValid && !isSameError(previousError, error)) ||\n    (isValid && get(fieldsWithValidation, name) && !get(validFields, name))\n  );\n}\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\nimport { ValidationRule, ValidationValueMessage } from '../types';\n\nconst isValueMessage = (\n  value?: ValidationRule,\n): value is ValidationValueMessage => isObject(value) && !isRegex(value);\n\nexport default (validationData?: ValidationRule) =>\n  isValueMessage(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","import { isValidElement } from 'react';\nimport isString from '../utils/isString';\nimport isObject from '../utils/isObject';\nimport { Message } from '../types';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || (isObject(value) && isValidElement(value));\n","import isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport { FieldError, ValidateResult, Ref } from '../types';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import {\n  InternalFieldName,\n  ValidateResult,\n  InternalFieldErrors,\n} from '../types';\n\nexport default <TFieldValues>(\n  name: InternalFieldName<TFieldValues>,\n  validateAllFieldCriteria: boolean,\n  errors: InternalFieldErrors<TFieldValues>,\n  type: string,\n  message: ValidateResult,\n) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n\n    return {\n      ...error,\n      types: {\n        ...(error && error.types ? error.types : {}),\n        [type]: message || true,\n      },\n    };\n  }\n\n  return {};\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getCheckboxValue from './getCheckboxValue';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isRadioInput from '../utils/isRadioInput';\nimport getValueAndMessage from './getValueAndMessage';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isString from '../utils/isString';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isObject from '../utils/isObject';\nimport isFunction from '../utils/isFunction';\nimport getFieldsValue from './getFieldValue';\nimport isRegex from '../utils/isRegex';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport getValidateError from './getValidateError';\nimport appendErrors from './appendErrors';\nimport { INPUT_VALIDATION_RULES } from '../constants';\nimport {\n  Field,\n  FieldValues,\n  FieldRefs,\n  Message,\n  FieldError,\n  InternalFieldName,\n  InternalFieldErrors,\n} from '../types';\n\nexport default async <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  validateAllFieldCriteria: boolean,\n  {\n    ref,\n    ref: { type, value },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate,\n  }: Field,\n  shallowFieldsStateRef: React.MutableRefObject<Record<string, any>>,\n): Promise<InternalFieldErrors<TFieldValues>> => {\n  const fields = fieldsRef.current;\n  const name: InternalFieldName<TFieldValues> = ref.name;\n  const error: InternalFieldErrors<TFieldValues> = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...(exceedMax\n        ? appendErrorsCurry(maxType, message)\n        : appendErrorsCurry(minType, message)),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\n      (isBoolean(value) && !value) ||\n      (isCheckBox && !getCheckboxValue(options).isValid) ||\n      (isRadio && !getRadioValue(options).isValid))\n  ) {\n    const { value: requiredValue, message: requiredMessage } = isMessage(\n      required,\n    )\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (requiredValue) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message: requiredMessage,\n        ref: isRadioOrCheckbox\n          ? (((fields[name] as Field).options || [])[0] || {}).ref\n          : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\n    const { value: minValue, message: minMessage } = getValueAndMessage(min);\n\n    if (type === 'number' || (!type && !isNaN(value))) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(value);\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(value);\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxMessage,\n        minMessage,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage,\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage,\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax =\n      !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n    const exceedMin =\n      !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (pattern && !isEmpty) {\n    const { value: patternValue, message: patternMessage } = getValueAndMessage(\n      pattern,\n    );\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldsValue(fieldsRef, name, shallowFieldsStateRef);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","import isPrimitive from './isPrimitive';\nimport isObject from './isObject';\n\nexport const getPath = <T extends string, U extends object | unknown[]>(\n  path: T,\n  values: U,\n): string[] => {\n  const getInnerPath = <K>(key: K, value: U, isObject?: boolean) => {\n    const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return Object.entries(values)\n    .map(([key, value]) => getInnerPath(key, value, isObject(values)))\n    .flat(Infinity) as string[];\n};\n","import get from '../utils/get';\nimport { getPath } from '../utils/getPath';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isArray from '../utils/isArray';\nimport {\n  DeepPartial,\n  FieldValue,\n  FieldValues,\n  InternalFieldName,\n  UnpackNestedValue,\n} from '../types';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldValues: TFieldValues,\n  fieldName: InternalFieldName<TFieldValues>,\n  watchFields: Set<InternalFieldName<TFieldValues>>,\n  inputValue: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  isSingleField?: boolean,\n):\n  | FieldValue<TFieldValues>\n  | UnpackNestedValue<DeepPartial<TFieldValues>>\n  | undefined => {\n  let value;\n\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || isArray(value)) {\n      getPath(fieldName, value).forEach((name) => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value)\n    ? isSingleField\n      ? inputValue\n      : get(inputValue, fieldName)\n    : value;\n};\n","export default ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll,\n}: {\n  isOnAll?: boolean;\n  isOnBlur?: boolean;\n  isOnChange?: boolean;\n  isReValidateOnBlur?: boolean;\n  isReValidateOnChange?: boolean;\n  isBlurEvent?: boolean;\n  isSubmitted?: boolean;\n  isOnTouch?: boolean;\n  isTouched?: boolean;\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n","export default (name: string) => name.substring(0, name.indexOf('['));\n","import isObject from '../utils/isObject';\nimport isArray from '../utils/isArray';\n\nexport default function deepEqual(object1: any = [], object2: any = []) {\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (const key of keys1) {\n    const val1 = object1[key];\n    const val2 = object2[key];\n\n    if (\n      (isObject(val1) || isArray(val1)) && (isObject(val2) || isArray(val2))\n        ? !deepEqual(val1, val2)\n        : val1 !== val2\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { FieldValues, InternalFieldName } from '../types';\n\nexport const isMatchFieldArrayName = (name: string, searchName: string) =>\n  RegExp(\n    `^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]'),\n  ).test(name);\n\nexport default (\n  names: Set<InternalFieldName<FieldValues>>,\n  name: InternalFieldName<FieldValues>,\n) => [...names].some((current) => isMatchFieldArrayName(name, current));\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-one`;\n","import * as React from 'react';\nimport { Field, FieldRefs } from '../types';\nimport isDetached from './isDetached';\n\nexport default function onDomRemove<TFieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  removeFieldEventListenerAndRef: (\n    field: Field | undefined,\n    forceDelete?: boolean,\n  ) => void,\n): MutationObserver {\n  const observer = new MutationObserver((): void => {\n    for (const field of Object.values(fieldsRef.current)) {\n      if (field && field.options) {\n        for (const option of field.options) {\n          if (option && option.ref && isDetached(option.ref)) {\n            removeFieldEventListenerAndRef(field);\n          }\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true,\n  });\n\n  return observer;\n}\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n","import isRadioInput from './isRadioInput';\nimport isCheckBoxInput from './isCheckBoxInput';\nimport { FieldElement } from '../types';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","import * as React from 'react';\nimport attachEventListeners from './logic/attachEventListeners';\nimport transformToNestObject from './logic/transformToNestObject';\nimport focusOnErrorField from './logic/focusOnErrorField';\nimport findRemovedFieldAndRemoveListener from './logic/findRemovedFieldAndRemoveListener';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport shouldRenderBasedOnError from './logic/shouldRenderBasedOnError';\nimport validateField from './logic/validateField';\nimport assignWatchFields from './logic/assignWatchFields';\nimport skipValidation from './logic/skipValidation';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport deepEqual from './utils/deepEqual';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isRadioInput from './utils/isRadioInput';\nimport isSelectInput from './utils/isSelectInput';\nimport isFileInput from './utils/isFileInput';\nimport onDomRemove from './utils/onDomRemove';\nimport isObject from './utils/isObject';\nimport { getPath } from './utils/getPath';\nimport isPrimitive from './utils/isPrimitive';\nimport isFunction from './utils/isFunction';\nimport isArray from './utils/isArray';\nimport isString from './utils/isString';\nimport isSameError from './utils/isSameError';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport unset from './utils/unset';\nimport modeChecker from './utils/validationModeChecker';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport filterOutFalsy from './utils/filterOutFalsy';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isHTMLElement from './utils/isHTMLElement';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  UseFormMethods,\n  FieldValues,\n  UnpackNestedValue,\n  FieldName,\n  InternalFieldName,\n  FieldValue,\n  FieldErrors,\n  Field,\n  FieldRefs,\n  UseFormOptions,\n  ValidationRules,\n  SubmitHandler,\n  FieldElement,\n  FormStateProxy,\n  ReadFormState,\n  Ref,\n  HandleChange,\n  RadioOrCheckboxOption,\n  OmitResetState,\n  DefaultValuesAtRender,\n  NestedValue,\n  SetValueConfig,\n  ErrorOption,\n  FormState,\n  SubmitErrorHandler,\n  FieldNamesMarkedBoolean,\n  LiteralToPrimitive,\n  DeepPartial,\n  NonUndefined,\n  InternalNameSet,\n  DefaultValues,\n  FieldError,\n} from './types';\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isWeb =\n  typeof document !== UNDEFINED &&\n  !isWindowUndefined &&\n  !isUndefined(window.HTMLElement);\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {},\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode,\n}: UseFormOptions<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs<TFieldValues>>({});\n  const fieldArrayDefaultValuesRef = React.useRef<\n    Record<InternalFieldName<FieldValues>, unknown[]>\n  >({});\n  const watchFieldsRef = React.useRef<InternalNameSet<TFieldValues>>(new Set());\n  const useWatchFieldsRef = React.useRef<\n    Record<string, Set<InternalFieldName<TFieldValues>>>\n  >({});\n  const useWatchRenderFunctionsRef = React.useRef<\n    Record<InternalFieldName<FieldValues>, () => void>\n  >({});\n  const fieldsWithValidationRef = React.useRef<\n    FieldNamesMarkedBoolean<TFieldValues>\n  >({});\n  const validFieldsRef = React.useRef<FieldNamesMarkedBoolean<TFieldValues>>(\n    {},\n  );\n  const defaultValuesRef = React.useRef<DefaultValues<TFieldValues>>(\n    defaultValues,\n  );\n  const defaultValuesAtRenderRef = React.useRef(\n    {} as DefaultValuesAtRender<TFieldValues>,\n  );\n  const isUnMount = React.useRef(false);\n  const isWatchAllRef = React.useRef(false);\n  const handleChangeRef = React.useRef<HandleChange>();\n  const shallowFieldsStateRef = React.useRef(\n    shouldUnregister ? {} : defaultValues,\n  );\n  const resetFieldArrayFunctionRef = React.useRef<\n    Record<\n      InternalFieldName<FieldValues>,\n      (data?: UnpackNestedValue<DeepPartial<TFieldValues>>) => void\n    >\n  >({});\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<InternalNameSet<TFieldValues>>(\n    new Set(),\n  );\n  const modeRef = React.useRef(modeChecker(mode));\n  const { isOnSubmit, isOnTouch } = modeRef.current;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = React.useState<FormState<TFieldValues>>({\n    isDirty: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {},\n  });\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n  });\n  const formStateRef = React.useRef(formState);\n  const observerRef = React.useRef<MutationObserver | undefined>();\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnChange: isReValidateOnChange,\n  } = React.useRef(modeChecker(reValidateMode)).current;\n\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n\n  const updateFormState = React.useCallback(\n    (state: Partial<FormState<TFieldValues>> = {}) =>\n      !isUnMount.current &&\n      setFormState({\n        ...formStateRef.current,\n        ...state,\n      }),\n    [],\n  );\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      error: FieldError | undefined,\n      shouldRender: boolean | null = false,\n      state: {\n        dirtyFields?: FieldNamesMarkedBoolean<TFieldValues>;\n        isDirty?: boolean;\n        touched?: FieldNamesMarkedBoolean<TFieldValues>;\n      } = {},\n      isValid?: boolean,\n    ): boolean | void => {\n      let shouldReRender =\n        shouldRender ||\n        shouldRenderBasedOnError<TFieldValues>({\n          errors: formStateRef.current.errors,\n          error,\n          name,\n          validFields: validFieldsRef.current,\n          fieldsWithValidation: fieldsWithValidationRef.current,\n        });\n      const previousError = get(formStateRef.current.errors, name);\n\n      if (error) {\n        unset(validFieldsRef.current, name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !isSameError(previousError, error);\n        set(formStateRef.current.errors, name, error);\n      } else {\n        if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n          set(validFieldsRef.current, name, true);\n          shouldReRender = shouldReRender || previousError;\n        }\n        unset(formStateRef.current.errors, name);\n      }\n\n      if (\n        (shouldReRender && !isNullOrUndefined(shouldRender)) ||\n        !isEmptyObject(state)\n      ) {\n        updateFormState({\n          ...state,\n          errors: formStateRef.current.errors,\n          ...(resolverRef.current ? { isValid: !!isValid } : {}),\n        });\n      }\n    },\n    [],\n  );\n\n  const setFieldValue = React.useCallback(\n    (\n      { ref, options }: Field,\n      rawValue:\n        | FieldValue<TFieldValues>\n        | UnpackNestedValue<DeepPartial<TFieldValues>>\n        | string[]\n        | undefined\n        | null\n        | boolean,\n    ) => {\n      const value =\n        isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\n          ? ''\n          : rawValue;\n\n      if (isRadioInput(ref) && options) {\n        options.forEach(\n          ({ ref: radioRef }: { ref: HTMLInputElement }) =>\n            (radioRef.checked = radioRef.value === value),\n        );\n      } else if (isFileInput(ref) && !isString(value)) {\n        ref.files = value as FileList;\n      } else if (isMultipleSelect(ref)) {\n        [...ref.options].forEach(\n          (selectRef) =>\n            (selectRef.selected = (value as string[]).includes(\n              selectRef.value,\n            )),\n        );\n      } else if (isCheckBoxInput(ref) && options) {\n        options.length > 1\n          ? options.forEach(\n              ({ ref: checkboxRef }) =>\n                (checkboxRef.checked = isArray(value)\n                  ? !!(value as []).find(\n                      (data: string) => data === checkboxRef.value,\n                    )\n                  : value === checkboxRef.value),\n            )\n          : (options[0].ref.checked = !!value);\n      } else {\n        ref.value = value;\n      }\n    },\n    [],\n  );\n\n  const updateAndGetDirtyState = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      shouldRender = true,\n    ): {\n      dirtyFields?: FieldNamesMarkedBoolean<TFieldValues>;\n      isDirty?: boolean;\n      touched?: FieldNamesMarkedBoolean<TFieldValues>;\n    } => {\n      if (\n        !fieldsRef.current[name] ||\n        (!readFormStateRef.current.isDirty &&\n          !readFormStateRef.current.dirtyFields)\n      ) {\n        return {};\n      }\n\n      const isFieldDirty =\n        defaultValuesAtRenderRef.current[name] !==\n        getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n      const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n      const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n      const previousIsDirty = formStateRef.current.isDirty;\n\n      isFieldDirty\n        ? set(formStateRef.current.dirtyFields, name, true)\n        : unset(formStateRef.current.dirtyFields, name);\n\n      const state = {\n        isDirty:\n          (isFieldArray &&\n            !deepEqual(\n              get(getValues(), getFieldArrayParentName(name)),\n              get(defaultValuesRef.current, getFieldArrayParentName(name)),\n            )) ||\n          !isEmptyObject(formStateRef.current.dirtyFields),\n        dirtyFields: formStateRef.current.dirtyFields,\n      };\n\n      const isChanged =\n        (readFormStateRef.current.isDirty &&\n          previousIsDirty !== state.isDirty) ||\n        (readFormStateRef.current.dirtyFields &&\n          isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\n\n      if (isChanged && shouldRender) {\n        formStateRef.current = {\n          ...formStateRef.current,\n          ...state,\n        };\n        updateFormState({\n          ...state,\n        });\n      }\n\n      return isChanged ? state : {};\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName<TFieldValues>,\n      skipReRender?: boolean | null,\n    ): Promise<boolean> => {\n      if (fieldsRef.current[name]) {\n        const error = (\n          await validateField<TFieldValues>(\n            fieldsRef,\n            isValidateAllFieldCriteria,\n            fieldsRef.current[name] as Field,\n            shallowFieldsStateRef,\n          )\n        )[name];\n\n        shouldRenderBaseOnError(name, error, skipReRender);\n\n        return isUndefined(error);\n      }\n\n      return false;\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      names:\n        | InternalFieldName<TFieldValues>\n        | InternalFieldName<TFieldValues>[],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getValues(),\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const previousFormIsValid = formStateRef.current.isValid;\n\n      if (isArray(names)) {\n        const isInputsValid = names\n          .map((name) => {\n            const error = get(errors, name);\n\n            error\n              ? set(formStateRef.current.errors, name, error)\n              : unset(formStateRef.current.errors, name);\n\n            return !error;\n          })\n          .every(Boolean);\n\n        updateFormState({\n          isValid: isEmptyObject(errors),\n          errors: formStateRef.current.errors,\n        });\n\n        return isInputsValid;\n      } else {\n        const error = get(errors, names);\n\n        shouldRenderBaseOnError(\n          names,\n          error,\n          previousFormIsValid !== isEmptyObject(errors),\n          {},\n          isEmptyObject(errors),\n        );\n\n        return !error;\n      }\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const trigger = React.useCallback(\n    async (\n      name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n    ): Promise<boolean> => {\n      const fields = name || Object.keys(fieldsRef.current);\n\n      if (resolverRef.current) {\n        return executeSchemaOrResolverValidation(fields);\n      }\n\n      if (isArray(fields)) {\n        const result = await Promise.all(\n          fields.map(async (data) => await executeValidation(data, null)),\n        );\n        updateFormState();\n        return result.every(Boolean);\n      }\n\n      return await executeValidation(fields);\n    },\n    [executeSchemaOrResolverValidation, executeValidation],\n  );\n\n  const setInternalValues = React.useCallback(\n    <T extends string, U extends object | unknown[]>(\n      name: T,\n      value: U,\n      { shouldDirty, shouldValidate }: SetValueConfig,\n    ) => {\n      getPath(name, value).forEach((fieldName) => {\n        const data = {};\n        const field = fieldsRef.current[fieldName];\n\n        if (field) {\n          set(data, name, value);\n          setFieldValue(field, get(data, fieldName));\n\n          if (shouldDirty) {\n            updateAndGetDirtyState(fieldName);\n          }\n\n          if (shouldValidate) {\n            trigger(fieldName as FieldName<TFieldValues>);\n          }\n        }\n      });\n    },\n    [trigger, setFieldValue, updateAndGetDirtyState],\n  );\n\n  const setInternalValue = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      value: FieldValue<TFieldValues> | null | undefined | boolean,\n      config: SetValueConfig,\n    ) => {\n      if (fieldsRef.current[name]) {\n        setFieldValue(fieldsRef.current[name] as Field, value);\n        config.shouldDirty && updateAndGetDirtyState(name);\n      } else if (!isPrimitive(value)) {\n        setInternalValues(name, value, config);\n\n        if (\n          isNameInFieldArray(fieldArrayNamesRef.current, name) ||\n          fieldArrayNamesRef.current.has(name)\n        ) {\n          const fieldArrayParentName = getFieldArrayParentName(name) || name;\n          fieldArrayDefaultValuesRef.current[fieldArrayParentName] = value;\n          resetFieldArrayFunctionRef.current[fieldArrayParentName]({\n            [name]: value,\n          } as UnpackNestedValue<DeepPartial<TFieldValues>>);\n        }\n      }\n\n      !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n    },\n    [updateAndGetDirtyState, setFieldValue, setInternalValues],\n  );\n\n  const isFieldWatched = (name: string) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = (name: string, found = true): boolean => {\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (const key in useWatchFieldsRef.current) {\n        if (\n          !name ||\n          useWatchFieldsRef.current[key].has(name) ||\n          useWatchFieldsRef.current[key].has(getFieldArrayParentName(name)) ||\n          !useWatchFieldsRef.current[key].size\n        ) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    value: NonUndefined<TFieldValue> extends NestedValue<infer U>\n      ? U\n      : UnpackNestedValue<DeepPartial<LiteralToPrimitive<TFieldValue>>>,\n    config: SetValueConfig = {},\n  ): void {\n    setInternalValue(name, value as TFieldValues[string], config);\n\n    if (isFieldWatched(name)) {\n      updateFormState();\n    }\n\n    renderWatchedInputs(name);\n\n    if (config.shouldValidate) {\n      trigger(name as any);\n    }\n  }\n\n  handleChangeRef.current = handleChangeRef.current\n    ? handleChangeRef.current\n    : async ({ type, target }: Event): Promise<void | boolean> => {\n        const name = (target as Ref)!.name;\n        const field = fieldsRef.current[name];\n        let error;\n        let isValid;\n\n        if (field) {\n          const isBlurEvent = type === EVENTS.BLUR;\n          const shouldSkipValidation = skipValidation({\n            isBlurEvent,\n            isReValidateOnChange,\n            isReValidateOnBlur,\n            isTouched: !!get(formStateRef.current.touched, name),\n            isSubmitted: formStateRef.current.isSubmitted,\n            ...modeRef.current,\n          });\n          let state = updateAndGetDirtyState(name, false);\n          let shouldRender = !isEmptyObject(state) || isFieldWatched(name);\n\n          if (\n            isBlurEvent &&\n            !get(formStateRef.current.touched, name) &&\n            readFormStateRef.current.touched\n          ) {\n            set(formStateRef.current.touched, name, true);\n            state = {\n              ...state,\n              touched: formStateRef.current.touched,\n            };\n          }\n\n          if (shouldSkipValidation) {\n            renderWatchedInputs(name);\n            return (\n              (!isEmptyObject(state) ||\n                (shouldRender && isEmptyObject(state))) &&\n              updateFormState(state)\n            );\n          }\n\n          if (resolverRef.current) {\n            const { errors } = await resolverRef.current(\n              getValues(),\n              contextRef.current,\n              isValidateAllFieldCriteria,\n            );\n            const previousFormIsValid = formStateRef.current.isValid;\n\n            error = get(errors, name);\n\n            isValid = isEmptyObject(errors);\n\n            if (previousFormIsValid !== isValid) {\n              shouldRender = true;\n            }\n          } else {\n            error = (\n              await validateField<TFieldValues>(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              )\n            )[name];\n          }\n\n          renderWatchedInputs(name);\n          shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n        }\n      };\n\n  function getValues(): UnpackNestedValue<TFieldValues>;\n  function getValues<TFieldName extends string, TFieldValue extends unknown>(\n    name: TFieldName,\n  ): TFieldName extends keyof TFieldValues\n    ? UnpackNestedValue<TFieldValues>[TFieldName]\n    : TFieldValue;\n  function getValues<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function getValues(payload?: string | string[]): unknown {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (isArray(payload)) {\n      const data = {};\n\n      for (const name of payload) {\n        set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      }\n\n      return data;\n    }\n\n    return getFieldsValues(fieldsRef, shallowFieldsStateRef);\n  }\n\n  const validateResolver = React.useCallback(\n    async (values = {}) => {\n      const { errors } = await resolverRef.current!(\n        {\n          ...defaultValuesRef.current,\n          ...getValues(),\n          ...values,\n        },\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const previousFormIsValid = formStateRef.current.isValid;\n      const isValid = isEmptyObject(errors);\n\n      if (previousFormIsValid !== isValid) {\n        updateFormState({\n          isValid,\n        });\n      }\n    },\n    [isValidateAllFieldCriteria],\n  );\n\n  const removeFieldEventListener = React.useCallback(\n    (field: Field, forceDelete?: boolean) =>\n      findRemovedFieldAndRemoveListener(\n        fieldsRef,\n        handleChangeRef.current!,\n        field,\n        shallowFieldsStateRef,\n        shouldUnregister,\n        forceDelete,\n      ),\n    [shouldUnregister],\n  );\n\n  const removeFieldEventListenerAndRef = React.useCallback(\n    (field: Field | undefined, forceDelete?: boolean) => {\n      if (field) {\n        removeFieldEventListener(field, forceDelete);\n\n        if (shouldUnregister && !filterOutFalsy(field.options || []).length) {\n          delete defaultValuesAtRenderRef.current[field.ref.name];\n          unset(validFieldsRef.current, field.ref.name);\n          unset(fieldsWithValidationRef.current, field.ref.name);\n          unset(formStateRef.current.errors, field.ref.name);\n          unset(formStateRef.current.dirtyFields, field.ref.name);\n          unset(formStateRef.current.touched, field.ref.name);\n\n          updateFormState({\n            errors: formStateRef.current.errors,\n            isDirty: !isEmptyObject(formStateRef.current.dirtyFields),\n            dirtyFields: formStateRef.current.dirtyFields,\n            touched: formStateRef.current.touched,\n          });\n\n          resolverRef.current && validateResolver();\n        }\n      }\n    },\n    [validateResolver, removeFieldEventListener],\n  );\n\n  function clearErrors(\n    name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    name &&\n      (isArray(name) ? name : [name]).forEach((inputName) =>\n        fieldsRef.current[inputName]\n          ? delete formStateRef.current.errors[inputName]\n          : unset(formStateRef.current.errors, inputName),\n      );\n\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {},\n    });\n  }\n\n  function setError(\n    name: FieldName<TFieldValues>,\n    error: ErrorOption = {},\n  ): void {\n    const ref = (fieldsRef.current[name] || {})!.ref;\n\n    set(formStateRef.current.errors, name, {\n      ...error,\n      ref,\n    });\n\n    updateFormState({\n      isValid: false,\n      errors: formStateRef.current.errors,\n    });\n\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  const watchInternal = React.useCallback(\n    (\n      fieldNames?: string | string[],\n      defaultValue?: unknown,\n      watchId?: string,\n    ) => {\n      const watchFields = watchId\n        ? useWatchFieldsRef.current[watchId]\n        : watchFieldsRef.current;\n      const combinedDefaultValues = isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : defaultValue;\n      const fieldValues = getFieldsValues<TFieldValues>(\n        fieldsRef,\n        shallowFieldsStateRef,\n        false,\n        fieldNames,\n      );\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (fieldNames) {\n          const fieldRefNames = Object.keys(fieldsRef.current);\n\n          if (fieldRefNames.length) {\n            (isArray(fieldNames) ? fieldNames : [fieldNames]).forEach(\n              (name) => {\n                if (\n                  !fieldRefNames.find((fieldName) => fieldName.startsWith(name))\n                ) {\n                  console.warn(\n                    `📋 watched fields: ${fieldNames} are not found.`,\n                  );\n                }\n              },\n            );\n          }\n        }\n      }\n\n      if (isString(fieldNames)) {\n        return assignWatchFields<TFieldValues>(\n          fieldValues,\n          fieldNames,\n          watchFields,\n          isUndefined(defaultValue)\n            ? get(combinedDefaultValues, fieldNames)\n            : (defaultValue as UnpackNestedValue<DeepPartial<TFieldValues>>),\n          true,\n        );\n      }\n\n      if (isArray(fieldNames)) {\n        return fieldNames.reduce(\n          (previous, name) => ({\n            ...previous,\n            [name]: assignWatchFields<TFieldValues>(\n              fieldValues,\n              name,\n              watchFields,\n              combinedDefaultValues as UnpackNestedValue<\n                DeepPartial<TFieldValues>\n              >,\n            ),\n          }),\n          {},\n        );\n      }\n\n      if (isUndefined(watchId)) {\n        isWatchAllRef.current = true;\n      }\n\n      return transformToNestObject(\n        (!isEmptyObject(fieldValues) && fieldValues) ||\n          (combinedDefaultValues as FieldValues),\n      );\n    },\n    [],\n  );\n\n  function watch(): UnpackNestedValue<TFieldValues>;\n  function watch<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    defaultValue?: UnpackNestedValue<LiteralToPrimitive<TFieldValue>>,\n  ): UnpackNestedValue<LiteralToPrimitive<TFieldValue>>;\n  function watch<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n    defaultValues?: UnpackNestedValue<\n      DeepPartial<Pick<TFieldValues, TFieldName>>\n    >,\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function watch(\n    names: string[],\n    defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ): UnpackNestedValue<DeepPartial<TFieldValues>>;\n  function watch(\n    fieldNames?: string | string[],\n    defaultValue?: unknown,\n  ): unknown {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(\n    name: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    (isArray(name) ? name : [name]).forEach((fieldName) =>\n      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true),\n    );\n  }\n\n  function registerFieldRef<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: TFieldElement & Ref,\n    validateOptions: ValidationRules | null = {},\n  ): ((name: InternalFieldName<TFieldValues>) => void) | void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn(\n          '📋 Field is missing `name` attribute',\n          ref,\n          `https://react-hook-form.com/api#useForm`,\n        );\n      }\n\n      if (\n        fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\n        !RegExp(\n          `^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`\n            .replace(/\\[/g, '\\\\[')\n            .replace(/\\]/g, '\\\\]'),\n        ).test(ref.name)\n      ) {\n        return console.warn(\n          '📋 `name` prop should be in object shape: name=\"test[index].name\"',\n          ref,\n          'https://react-hook-form.com/api#useFieldArray',\n        );\n      }\n    }\n\n    const { name, type, value } = ref;\n    const fieldRefAndValidationOptions = {\n      ref,\n      ...validateOptions,\n    };\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    const compareRef = (currentRef: Ref) =>\n      isWeb && (!isHTMLElement(ref) || currentRef === ref);\n    let field = fields[name] as Field;\n    let isEmptyDefaultValue = true;\n    let isFieldArray;\n    let defaultValue;\n\n    if (\n      field &&\n      (isRadioOrCheckbox\n        ? isArray(field.options) &&\n          filterOutFalsy(field.options).find((option) => {\n            return value === option.ref.value && compareRef(option.ref);\n          })\n        : compareRef(field.ref))\n    ) {\n      fields[name] = {\n        ...field,\n        ...validateOptions,\n      };\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox\n        ? {\n            options: [\n              ...filterOutFalsy((field && field.options) || []),\n              {\n                ref,\n              } as RadioOrCheckboxOption,\n            ],\n            ref: { type, name },\n            ...validateOptions,\n          }\n        : {\n            ...fieldRefAndValidationOptions,\n          };\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n\n    const isEmptyUnmountFields = isUndefined(\n      get(shallowFieldsStateRef.current, name),\n    );\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(\n        isEmptyUnmountFields\n          ? defaultValuesRef.current\n          : shallowFieldsStateRef.current,\n        name,\n      );\n      isEmptyDefaultValue = isUndefined(defaultValue);\n      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(field, defaultValue);\n      }\n    }\n\n    if (resolver && !isFieldArray && readFormStateRef.current.isValid) {\n      validateResolver();\n    } else if (!isEmptyObject(validateOptions)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(\n          fieldsRef,\n          isValidateAllFieldCriteria,\n          field,\n          shallowFieldsStateRef,\n        ).then((error: FieldErrors) => {\n          const previousFormIsValid = formStateRef.current.isValid;\n\n          isEmptyObject(error)\n            ? set(validFieldsRef.current, name, true)\n            : unset(validFieldsRef.current, name);\n\n          if (previousFormIsValid !== isEmptyObject(error)) {\n            updateFormState();\n          }\n        });\n      }\n    }\n\n    if (\n      !defaultValuesAtRenderRef.current[name] &&\n      !(isFieldArray && isEmptyDefaultValue)\n    ) {\n      const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n      defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue\n        ? isObject(fieldValue)\n          ? { ...fieldValue }\n          : fieldValue\n        : defaultValue;\n    }\n\n    if (type) {\n      attachEventListeners(\n        isRadioOrCheckbox && field.options\n          ? field.options[field.options.length - 1]\n          : field,\n        isRadioOrCheckbox || isSelectInput(ref),\n        handleChangeRef.current,\n      );\n    }\n  }\n\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    rules?: ValidationRules,\n  ): (ref: (TFieldElement & Ref) | null) => void;\n  function register(\n    name: FieldName<TFieldValues>,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: (TFieldElement & Ref) | null,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    refOrValidationOptions?:\n      | FieldName<TFieldValues>\n      | ValidationRules\n      | (TFieldElement & Ref)\n      | null,\n    rules?: ValidationRules,\n  ): ((ref: (TFieldElement & Ref) | null) => void) | void {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldRef({ name: refOrValidationOptions }, rules);\n      } else if (\n        isObject(refOrValidationOptions) &&\n        'name' in refOrValidationOptions\n      ) {\n        registerFieldRef(refOrValidationOptions, rules);\n      } else {\n        return (ref: (TFieldElement & Ref) | null) =>\n          ref && registerFieldRef(ref, refOrValidationOptions);\n      }\n    }\n  }\n\n  const handleSubmit = React.useCallback(\n    <TSubmitFieldValues extends FieldValues = TFieldValues>(\n      onValid: SubmitHandler<TSubmitFieldValues>,\n      onInvalid?: SubmitErrorHandler<TFieldValues>,\n    ) => async (e?: React.BaseSyntheticEvent): Promise<void> => {\n      if (e && e.preventDefault) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldErrors: FieldErrors<TFieldValues> = {};\n      let fieldValues = getFieldsValues(fieldsRef, shallowFieldsStateRef, true);\n\n      if (readFormStateRef.current.isSubmitting) {\n        updateFormState({\n          isSubmitting: true,\n        });\n      }\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            fieldValues,\n            contextRef.current,\n            isValidateAllFieldCriteria,\n          );\n          formStateRef.current.errors = errors;\n          fieldErrors = errors;\n          fieldValues = values;\n        } else {\n          for (const field of Object.values(fieldsRef.current)) {\n            if (field) {\n              const {\n                ref: { name },\n              } = field;\n\n              const fieldError = await validateField(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              );\n\n              if (fieldError[name]) {\n                set(fieldErrors, name, fieldError[name]);\n                unset(validFieldsRef.current, name);\n              } else if (get(fieldsWithValidationRef.current, name)) {\n                unset(formStateRef.current.errors, name);\n                set(validFieldsRef.current, name, true);\n              }\n            }\n          }\n        }\n\n        if (\n          isEmptyObject(fieldErrors) &&\n          Object.keys(formStateRef.current.errors).every(\n            (name) => name in fieldsRef.current,\n          )\n        ) {\n          updateFormState({\n            errors: {},\n            isSubmitting: true,\n          });\n          await onValid(\n            fieldValues as UnpackNestedValue<TSubmitFieldValues>,\n            e,\n          );\n        } else {\n          formStateRef.current.errors = {\n            ...formStateRef.current.errors,\n            ...fieldErrors,\n          };\n          if (onInvalid) {\n            await onInvalid(fieldErrors, e);\n          }\n          if (shouldFocusError) {\n            focusOnErrorField(fieldsRef.current, fieldErrors);\n          }\n        }\n      } finally {\n        updateFormState({\n          isSubmitted: true,\n          isSubmitting: false,\n          isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n          errors: formStateRef.current.errors,\n          submitCount: formStateRef.current.submitCount + 1,\n        });\n      }\n    },\n    [shouldFocusError, isValidateAllFieldCriteria],\n  );\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields,\n  }: OmitResetState) => {\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    defaultValuesAtRenderRef.current = {} as DefaultValuesAtRender<\n      TFieldValues\n    >;\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n\n    updateFormState({\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isSubmitting: false,\n      isSubmitSuccessful: false,\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isValid: isValid ? formStateRef.current.isValid : true,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {},\n    });\n  };\n\n  const reset = (\n    values?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n    omitResetState: OmitResetState = {},\n  ): void => {\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const { ref, options } = field;\n          const inputRef =\n            isRadioOrCheckboxFunction(ref) && isArray(options)\n              ? options[0].ref\n              : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n\n    defaultValuesRef.current = values || { ...defaultValuesRef.current };\n\n    if (values) {\n      renderWatchedInputs('');\n    }\n\n    shallowFieldsStateRef.current = shouldUnregister ? {} : values || {};\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(\n      (resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray(),\n    );\n\n    resetRefs(omitResetState);\n  };\n\n  observerRef.current =\n    observerRef.current || !isWeb\n      ? observerRef.current\n      : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n\n  React.useEffect(() => {\n    isUnMount.current = false;\n\n    return () => {\n      isUnMount.current = true;\n\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      fieldsRef.current &&\n        Object.values(fieldsRef.current).forEach((field) =>\n          removeFieldEventListenerAndRef(field, true),\n        );\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid =\n      deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\n      isEmptyObject(formStateRef.current.errors);\n  }\n\n  const commonProps = {\n    trigger,\n    setValue: React.useCallback(setValue, [setInternalValue, trigger]),\n    getValues: React.useCallback(getValues, []),\n    register: React.useCallback(register, [defaultValuesRef.current]),\n    unregister: React.useCallback(unregister, []),\n  };\n\n  const control = {\n    removeFieldEventListener,\n    renderWatchedInputs,\n    watchInternal,\n    mode: modeRef.current,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange,\n    },\n    fieldsRef,\n    isWatchAllRef,\n    watchFieldsRef,\n    resetFieldArrayFunctionRef,\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    fieldArrayDefaultValuesRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    readFormStateRef,\n    formStateRef,\n    defaultValuesRef,\n    shallowFieldsStateRef,\n    updateFormState,\n    shouldUnregister,\n    validateResolver: resolver ? validateResolver : undefined,\n    ...commonProps,\n  };\n\n  return {\n    watch,\n    control,\n    formState: isProxyEnabled\n      ? new Proxy(formState, {\n          get: (obj, prop: keyof FormStateProxy) => {\n            if (\n              process.env.NODE_ENV !== 'production' &&\n              prop === 'isValid' &&\n              isOnSubmit\n            ) {\n              console.warn(\n                '📋 `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState',\n              );\n            }\n\n            if (prop in obj) {\n              readFormStateRef.current[prop] = true;\n              return obj[prop];\n            }\n\n            return undefined;\n          },\n        })\n      : formState,\n    handleSubmit,\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    setError: React.useCallback(setError, []),\n    errors: formState.errors,\n    ...commonProps,\n  };\n}\n","import * as React from 'react';\nimport { UseFormMethods, FieldValues, FormProviderProps } from './types';\n\nconst FormContext = React.createContext<UseFormMethods | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormMethods<TFieldValues> =>\n  React.useContext(FormContext) as UseFormMethods<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>({\n  children,\n  ...props\n}: FormProviderProps<TFieldValues>) => (\n  <FormContext.Provider value={{ ...props } as UseFormMethods}>\n    {children}\n  </FormContext.Provider>\n);\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import isUndefined from './isUndefined';\nimport isArray from './isArray';\nimport filterOutFalsy from './filterOutFalsy';\n\nconst removeAt = <T>(data: T[], index: number): T[] => [\n  ...data.slice(0, index),\n  ...data.slice(index + 1),\n];\n\nfunction removeAtIndexes<T>(data: T[], index: number[]): T[] {\n  let k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return filterOutFalsy(data);\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : isArray(index)\n    ? removeAtIndexes(data, index)\n    : removeAt(data, index);\n","import isUndefined from './isUndefined';\nimport isArray from './isArray';\n\nexport default <T>(\n  data: (T | undefined)[],\n  from: number,\n  to: number,\n): (T | undefined)[] => {\n  if (isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n","import isArray from './isArray';\n\nexport default function prepend<T>(data: T[]): (T | undefined)[];\nexport default function prepend<T>(data: T[], value: T | T[]): T[];\nexport default function prepend<T>(\n  data: T[],\n  value?: T | T[],\n): (T | undefined)[] {\n  return [...(isArray(value) ? value : [value || undefined]), ...data];\n}\n","import isArray from './isArray';\n\nexport default function insert<T>(data: T[], index: number): (T | undefined)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | undefined)[] {\n  return [\n    ...data.slice(0, index),\n    ...(isArray(value) ? value : [value || undefined]),\n    ...data.slice(index),\n  ];\n}\n","import isArray from './isArray';\n\nexport default <T>(value: T | T[]): undefined[] | undefined =>\n  isArray(value) ? Array(value.length).fill(undefined) : undefined;\n","import isArray from './isArray';\nimport isObject from './isObject';\n\nfunction mapValueToBoolean<U>(value: U): boolean[] | Record<string, boolean>[] {\n  if (isObject(value)) {\n    const object: Record<string, boolean> = {};\n\n    for (const key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nexport default <T>(value: T) =>\n  ((isArray(value) ? value : [value]) as T[]).map(mapValueToBoolean).flat();\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport { isMatchFieldArrayName } from './logic/isNameInFieldArray';\nimport generateId from './logic/generateId';\nimport deepEqual from './utils/deepEqual';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport get from './utils/get';\nimport set from './utils/set';\nimport isUndefined from './utils/isUndefined';\nimport removeArrayAt from './utils/remove';\nimport unset from './utils/unset';\nimport moveArrayAt from './utils/move';\nimport swapArrayAt from './utils/swap';\nimport prependAt from './utils/prepend';\nimport isArray from './utils/isArray';\nimport insertAt from './utils/insert';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport filterBooleanArray from './utils/filterBooleanArray';\nimport filterOutFalsy from './utils/filterOutFalsy';\nimport {\n  Field,\n  FieldValues,\n  UseFieldArrayOptions,\n  Control,\n  ArrayField,\n  UnpackNestedValue,\n  DeepPartial,\n} from './types';\n\nconst appendId = <TValue extends object, TKeyName extends string>(\n  value: TValue,\n  keyName: TKeyName,\n): Partial<ArrayField<TValue, TKeyName>> => ({\n  [keyName]: generateId(),\n  ...value,\n});\n\nconst mapIds = <TData extends object, TKeyName extends string>(\n  data: TData | TData[],\n  keyName: TKeyName,\n) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\n\nexport const useFieldArray = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id',\n  TControl extends Control = Control\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayOptions<TKeyName, TControl>) => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        '📋 useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray',\n      );\n    }\n\n    if (!name) {\n      console.warn(\n        '📋 useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray',\n      );\n    }\n  }\n\n  const focusIndexRef = React.useRef(-1);\n  const {\n    isWatchAllRef,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    formStateRef,\n    formStateRef: {\n      current: { dirtyFields, touched },\n    },\n    shallowFieldsStateRef,\n    updateFormState,\n    readFormStateRef,\n    watchFieldsRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n    validateResolver,\n    renderWatchedInputs,\n    getValues,\n  } = control || methods.control;\n\n  const fieldArrayParentName = getFieldArrayParentName(name);\n  const getDefaultValues = () => [\n    ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\n      ? get(fieldArrayDefaultValuesRef.current, name, [])\n      : get(defaultValuesRef.current, name, [])),\n  ];\n  const memoizedDefaultValues = React.useRef<Partial<TFieldArrayValues>[]>(\n    getDefaultValues(),\n  );\n  const [fields, setFields] = React.useState<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(mapIds(memoizedDefaultValues.current, keyName));\n  const allFields = React.useRef<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(fields);\n\n  const getCurrentFieldsValues = () =>\n    get(getValues() || {}, name, allFields.current).map(\n      (item: Partial<TFieldArrayValues>, index: number) => ({\n        ...allFields.current[index],\n        ...item,\n      }),\n    );\n\n  allFields.current = fields;\n  fieldArrayNamesRef.current.add(name);\n\n  if (!get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\n    set(\n      fieldArrayDefaultValuesRef.current,\n      fieldArrayParentName,\n      get(defaultValuesRef.current, fieldArrayParentName),\n    );\n  }\n\n  const appendValueWithKey = (values: Partial<TFieldArrayValues>[]) =>\n    values.map((value: Partial<TFieldArrayValues>) => appendId(value, keyName));\n\n  const setFieldAndValidState = (\n    fieldsValues: Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n  ) => {\n    setFields(fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = {};\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const getIsDirtyState = (\n    flagOrFields?: (Partial<TFieldArrayValues> | undefined)[],\n  ): boolean =>\n    (readFormStateRef.current.isDirty ||\n      readFormStateRef.current.dirtyFields) &&\n    (isUndefined(flagOrFields) ||\n      !deepEqual(\n        flagOrFields.map(({ [keyName]: omitted, ...rest } = {}) => rest),\n        get(defaultValuesRef.current, name),\n      ));\n\n  const resetFields = () => {\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\n        removeFieldEventListener(fieldsRef.current[key] as Field, true);\n      }\n    }\n  };\n\n  const cleanup = <T>(ref: T) =>\n    !filterOutFalsy(get(ref, name, [])).length && unset(ref, name);\n\n  const batchStateUpdate = <T extends Function>(\n    method: T,\n    args: {\n      argA?: unknown;\n      argB?: unknown;\n      argC?: unknown;\n      argD?: unknown;\n    },\n    isDirty = true,\n    shouldSet = true,\n    shouldUpdateValid = false,\n  ) => {\n    if (get(shallowFieldsStateRef.current, name)) {\n      const output = method(\n        get(shallowFieldsStateRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n      cleanup(shallowFieldsStateRef.current);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      const output = method(\n        get(fieldArrayDefaultValuesRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\n      cleanup(fieldArrayDefaultValuesRef.current);\n    }\n\n    if (isArray(get(formStateRef.current.errors, name))) {\n      const output = method(\n        get(formStateRef.current.errors, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touched && get(touched, name)) {\n      const output = method(get(touched, name), args.argA, args.argB);\n      shouldSet && set(touched, name, output);\n      cleanup(touched);\n    }\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      const output = method(get(dirtyFields, name, []), args.argC, args.argD);\n      shouldSet && set(dirtyFields, name, output);\n      cleanup(dirtyFields);\n    }\n\n    if (\n      shouldUpdateValid &&\n      readFormStateRef.current.isValid &&\n      !validateResolver\n    ) {\n      set(\n        validFieldsRef.current,\n        name,\n        method(get(validFieldsRef.current, name, []), args.argA),\n      );\n      cleanup(validFieldsRef.current);\n\n      set(\n        fieldsWithValidationRef.current,\n        name,\n        method(get(fieldsWithValidationRef.current, name, []), args.argA),\n      );\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    updateFormState({\n      errors: formStateRef.current.errors,\n      dirtyFields,\n      isDirty,\n      touched,\n    });\n  };\n\n  const append = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    setFieldAndValidState([\n      ...allFields.current,\n      ...(isArray(value)\n        ? appendValueWithKey(value)\n        : [appendId(value, keyName)]),\n    ]);\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      set(dirtyFields, name, [\n        ...(isArray(get(dirtyFields, name))\n          ? get(dirtyFields, name)\n          : fillEmptyArray(allFields.current)),\n        ...filterBooleanArray(value),\n      ]);\n      updateFormState({\n        isDirty: true,\n        dirtyFields,\n      });\n    }\n\n    focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\n    renderWatchedInputs(name);\n  };\n\n  const prepend = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n\n    setFieldAndValidState(\n      prependAt(\n        getCurrentFieldsValues(),\n        isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)],\n      ),\n    );\n    resetFields();\n    batchStateUpdate(prependAt, {\n      argA: emptyArray,\n      argC: filterBooleanArray(value),\n    });\n    renderWatchedInputs(name);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = (index?: number | number[]) => {\n    const fieldValues = getCurrentFieldsValues();\n    setFieldAndValidState(removeArrayAt(fieldValues, index));\n    resetFields();\n    batchStateUpdate(\n      removeArrayAt,\n      {\n        argA: index,\n        argC: index,\n      },\n      getIsDirtyState(removeArrayAt(fieldValues, index)),\n      true,\n      true,\n    );\n\n    renderWatchedInputs(name);\n  };\n\n  const insert = (\n    index: number,\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n\n    setFieldAndValidState(\n      insertAt(\n        fieldValues,\n        index,\n        isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)],\n      ),\n    );\n    resetFields();\n    batchStateUpdate(\n      insertAt,\n      {\n        argA: index,\n        argB: emptyArray,\n        argC: index,\n        argD: filterBooleanArray(value),\n      },\n      getIsDirtyState(insertAt(fieldValues, index)),\n    );\n    renderWatchedInputs(name);\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      swapArrayAt,\n      {\n        argA: indexA,\n        argB: indexB,\n        argC: indexA,\n        argD: indexB,\n      },\n      getIsDirtyState(fieldValues),\n      false,\n    );\n    renderWatchedInputs(name);\n  };\n\n  const move = (from: number, to: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      moveArrayAt,\n      {\n        argA: from,\n        argB: to,\n        argC: from,\n        argD: to,\n      },\n      getIsDirtyState(fieldValues),\n      false,\n    );\n    renderWatchedInputs(name);\n  };\n\n  const reset = <TFieldValues>(\n    data?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ) => {\n    resetFields();\n    !data && unset(fieldArrayDefaultValuesRef.current, name);\n    unset(shallowFieldsStateRef.current, name);\n    memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\n    setFields(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  React.useEffect(() => {\n    const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      defaultValues.pop();\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues);\n    }\n\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else if (watchFieldsRef) {\n      let shouldRenderUseWatch = true;\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          updateFormState();\n          shouldRenderUseWatch = false;\n          break;\n        }\n      }\n\n      shouldRenderUseWatch && renderWatchedInputs(name);\n    }\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n        if (\n          key.startsWith(`${name}[${focusIndexRef.current}]`) &&\n          field!.ref.focus\n        ) {\n          field!.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n\n  React.useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = reset;\n    }\n\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert, [name]),\n    fields,\n  };\n};\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport isUndefined from './utils/isUndefined';\nimport isString from './utils/isString';\nimport generateId from './logic/generateId';\nimport get from './utils/get';\nimport isArray from './utils/isArray';\nimport isObject from './utils/isObject';\nimport {\n  DeepPartial,\n  UseWatchOptions,\n  FieldValues,\n  UnpackNestedValue,\n  Control,\n} from './types';\n\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  control?: Control;\n}): undefined | UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  defaultValue: UnpackNestedValue<TWatchFieldValue>;\n  control?: Control;\n}): UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  name: string[];\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValues>({\n  control,\n  name,\n  defaultValue,\n}: UseWatchOptions): TWatchFieldValues {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        '📋 useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch',\n      );\n    }\n\n    if (name === '') {\n      console.warn(\n        '📋 useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch',\n      );\n    }\n  }\n\n  const {\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    watchInternal,\n    defaultValuesRef,\n  } = control || methods.control;\n  const [value, setValue] = React.useState<unknown>(\n    isUndefined(defaultValue)\n      ? isString(name)\n        ? get(defaultValuesRef.current, name)\n        : isArray(name)\n        ? name.reduce(\n            (previous, inputName) => ({\n              ...previous,\n              [inputName]: get(defaultValuesRef.current, inputName),\n            }),\n            {},\n          )\n        : defaultValuesRef.current\n      : defaultValue,\n  );\n  const idRef = React.useRef<string>();\n  const defaultValueRef = React.useRef(defaultValue);\n\n  const updateWatchValue = React.useCallback(() => {\n    const value = watchInternal(name, defaultValueRef.current, idRef.current);\n    setValue(\n      isObject(value) ? { ...value } : isArray(value) ? [...value] : value,\n    );\n  }, [setValue, watchInternal, defaultValueRef, name, idRef]);\n\n  React.useEffect(() => {\n    const id = (idRef.current = generateId());\n    const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    const watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(name, defaultValueRef.current, id);\n\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [\n    name,\n    updateWatchValue,\n    useWatchRenderFunctionsRef,\n    useWatchFieldsRef,\n    watchInternal,\n    defaultValueRef,\n  ]);\n\n  return (isUndefined(value) ? defaultValue : value) as TWatchFieldValues;\n}\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isPrimitive from '../utils/isPrimitive';\n\nexport default (event: any) =>\n  isPrimitive(event) ||\n  !isObject(event.target) ||\n  (isObject(event.target) && !event.type)\n    ? event\n    : isUndefined(event.target.value)\n    ? event.target.checked\n    : event.target.value;\n","import * as React from 'react';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport getInputValue from './logic/getInputValue';\nimport skipValidation from './logic/skipValidation';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport { useFormContext } from './useFormContext';\nimport { VALUE } from './constants';\nimport { Control } from './types';\nimport { ControllerProps } from './types';\n\nconst Controller = <\n  TAs extends\n    | React.ReactElement\n    | React.ComponentType<any>\n    | 'input'\n    | 'select'\n    | 'textarea',\n  TControl extends Control = Control\n>({\n  name,\n  rules,\n  as,\n  render,\n  defaultValue,\n  control,\n  onFocus,\n  ...rest\n}: ControllerProps<TAs, TControl>) => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production' && !control && !methods) {\n    throw new Error(\n      '📋 Controller is missing `control` prop. https://react-hook-form.com/api#Controller',\n    );\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: { isReValidateOnBlur, isReValidateOnChange },\n    formStateRef: {\n      current: { isSubmitted, touched },\n    },\n    updateFormState,\n    readFormStateRef,\n    fieldsRef,\n    fieldArrayNamesRef,\n    shallowFieldsStateRef,\n  } = control || methods.control;\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n  const getInitialValue = () =>\n    !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\n      ? get(shallowFieldsStateRef.current, name)\n      : isUndefined(defaultValue)\n      ? get(defaultValuesRef.current, name)\n      : defaultValue;\n  const [value, setInputStateValue] = React.useState(getInitialValue());\n  const valueRef = React.useRef(value);\n  const onFocusRef = React.useRef(onFocus);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined(value)) {\n      console.warn(\n        `📋 ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`,\n      );\n    }\n\n    if ((!as && !render) || (as && render)) {\n      console.warn(\n        `📋 ${name} Controller should use either the 'as' or 'render' prop, not both. https://react-hook-form.com/api#Controller`,\n      );\n    }\n\n    if (!isNotFieldArray && isUndefined(defaultValue)) {\n      console.warn(\n        '📋 Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller',\n      );\n    }\n  }\n\n  const shouldValidate = (isBlurEvent?: boolean) =>\n    !skipValidation({\n      isBlurEvent,\n      isReValidateOnBlur,\n      isReValidateOnChange,\n      isSubmitted,\n      isTouched: !!get(touched, name),\n      ...mode,\n    });\n\n  const commonTask = ([event]: any[]) => {\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  const registerField = React.useCallback(() => {\n    if (process.env.NODE_ENV !== 'production' && !name) {\n      return console.warn(\n        '📋 Field is missing `name` prop. https://react-hook-form.com/api#Controller',\n      );\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = {\n        ref: fieldsRef.current[name]!.ref,\n        ...rules,\n      };\n    } else {\n      register(\n        Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\n          set(data) {\n            setInputStateValue(data);\n            valueRef.current = data;\n          },\n          get() {\n            return valueRef.current;\n          },\n        }),\n        rules,\n      );\n      if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  }, [rules, name, register]);\n\n  React.useEffect(\n    () => () => {\n      !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\n    },\n    [unregister, name, fieldArrayNamesRef],\n  );\n\n  React.useEffect(() => {\n    registerField();\n  }, [registerField]);\n\n  React.useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  const onBlur = () => {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched,\n      });\n    }\n\n    if (shouldValidate(true)) {\n      trigger(name);\n    }\n  };\n\n  const onChange = (...event: any[]) =>\n    setValue(name, commonTask(event), {\n      shouldValidate: shouldValidate(),\n      shouldDirty: true,\n    });\n\n  const props = {\n    ...rest,\n    onChange,\n    onBlur,\n    name,\n    value,\n  };\n\n  return as\n    ? React.isValidElement(as)\n      ? React.cloneElement(as, props)\n      : React.createElement(as as string, props as any)\n    : render\n    ? render({\n        onChange,\n        onBlur,\n        value,\n        name,\n      })\n    : null;\n};\n\nexport { Controller };\n"]},"metadata":{},"sourceType":"module"}